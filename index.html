<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>AI Image Generation: Complete Professor's Guide | YUV.AI</title>
    <meta name="description" content="Learn AI image generation from mathematics to implementation. Created by Yuval Avidani (YUV.AI)">
    <meta name="author" content="Yuval Avidani">
    
    <!-- Google Fonts for Professional Typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&family=Roboto:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Authentic Apple Color System (iOS 17/macOS Sonoma) */
            --apple-blue: #007AFF;
            --apple-blue-light: #5AC8FA;
            --apple-purple: #AF52DE;
            --apple-pink: #FF2D92;
            --apple-red: #FF3B30;
            --apple-orange: #FF9500;
            --apple-yellow: #FFCC00;
            --apple-green: #34C759;
            --apple-teal: #5AC8FA;
            --apple-indigo: #5856D6;
            
            /* Apple System Colors */
            --system-blue: #007AFF;
            --system-green: #34C759;
            --system-indigo: #5856D6;
            --system-orange: #FF9500;
            --system-pink: #FF2D92;
            --system-purple: #AF52DE;
            --system-red: #FF3B30;
            --system-teal: #5AC8FA;
            --system-yellow: #FFCC00;
            
            /* Apple Background System */
            --bg-primary: #FFFFFF;
            --bg-secondary: #F2F2F7;
            --bg-tertiary: #FFFFFF;
            --bg-grouped: #F2F2F7;
            --bg-system-grouped: #F2F2F7;
            --bg-secondary-grouped: #FFFFFF;
            --bg-tertiary-grouped: #F2F2F7;
            
            /* Apple Text System */
            --text-primary: #000000;
            --text-secondary: #3C3C43;
            --text-tertiary: rgba(60, 60, 67, 0.6);
            --text-quaternary: rgba(60, 60, 67, 0.3);
            --text-placeholder: rgba(60, 60, 67, 0.3);
            
            /* Apple Fill System */
            --fill-primary: rgba(120, 120, 128, 0.2);
            --fill-secondary: rgba(120, 120, 128, 0.16);
            --fill-tertiary: rgba(118, 118, 128, 0.12);
            --fill-quaternary: rgba(116, 116, 128, 0.08);
            
            /* Apple Gray System */
            --gray-1: #8E8E93;
            --gray-2: #AEAEB2;
            --gray-3: #C7C7CC;
            --gray-4: #D1D1D6;
            --gray-5: #E5E5EA;
            --gray-6: #F2F2F7;
            
            /* Apple Label Colors */
            --label-primary: #000000;
            --label-secondary: rgba(60, 60, 67, 0.6);
            --label-tertiary: rgba(60, 60, 67, 0.3);
            --label-quaternary: rgba(60, 60, 67, 0.18);
            
            /* Modal and Notification Colors */
            --modal-backdrop: rgba(0, 0, 0, 0.4);
            --notification-success: var(--system-green);
            --notification-error: var(--system-red);
            --notification-info: var(--system-blue);
            --notification-warning: var(--system-orange);
            
            /* Apple Shadow System */
            --shadow-1: 0 1px 3px rgba(0, 0, 0, 0.12);
            --shadow-2: 0 4px 6px rgba(0, 0, 0, 0.07);
            --shadow-3: 0 5px 15px rgba(0, 0, 0, 0.08);
            --shadow-4: 0 10px 24px rgba(0, 0, 0, 0.07);
            --shadow-5: 0 15px 35px rgba(0, 0, 0, 0.1);
            
            /* Apple Border Radius System */
            --radius-small: 6px;
            --radius-medium: 10px;
            --radius-large: 14px;
            --radius-xl: 20px;
            --radius-2xl: 28px;
            --fill-tertiary: #7676801F;
            --fill-quaternary: #74748014;
            
            /* Gray System */
            --gray-1: #8E8E93;
            --gray-2: #AEAEB2;
            --gray-3: #C7C7CC;
            --gray-4: #D1D1D6;
            --gray-5: #E5E5EA;
            --gray-6: #F2F2F7;
            
            /* Shadows */
            --shadow-1: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
            --shadow-2: 0 3px 6px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.12);
            --shadow-3: 0 10px 20px rgba(0, 0, 0, 0.15), 0 3px 6px rgba(0, 0, 0, 0.10);
            --shadow-4: 0 15px 25px rgba(0, 0, 0, 0.15), 0 5px 10px rgba(0, 0, 0, 0.05);
            
            /* Glassmorphism */
            --glass-bg: rgba(255, 255, 255, 0.25);
            --glass-border: rgba(255, 255, 255, 0.18);
            --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            
            /* Modal and Notification Glass */
            --modal-glass: rgba(255, 255, 255, 0.95);
            --notification-glass: rgba(255, 255, 255, 0.9);
            
            /* Border Radius */
            --radius-small: 6px;
            --radius-medium: 12px;
            --radius-large: 20px;
            --radius-xl: 28px;
        }

        body {
            /* Apple-authentic font stack */
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', Inter, 'Segoe UI', system-ui, Roboto, 'Helvetica Neue', Arial, 'Noto Sans Hebrew', sans-serif;
            background: var(--bg-primary);
            color: var(--label-primary);
            line-height: 1.47;
            font-size: 17px;
            font-weight: 400;
            margin: 0;
            padding: 80px 0 0 0;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
            direction: ltr;
            transition: direction 0.3s ease;
            min-height: 100vh;
        }
        
        body.rtl {
            direction: rtl;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', Inter, 'Segoe UI', system-ui, 'Heebo', 'Rubik', 'Noto Sans Hebrew', Arial, sans-serif;
        }
        
        /* Apple Typography Scale */
        .text-large-title {
            font-size: 34px;
            font-weight: 700;
            line-height: 1.12;
            letter-spacing: 0.41px;
        }
        
        .text-title-1 {
            font-size: 28px;
            font-weight: 700;
            line-height: 1.14;
            letter-spacing: 0.36px;
        }
        
        .text-title-2 {
            font-size: 22px;
            font-weight: 700;
            line-height: 1.18;
            letter-spacing: 0.35px;
        }
        
        .text-title-3 {
            font-size: 20px;
            font-weight: 600;
            line-height: 1.2;
            letter-spacing: 0.38px;
        }
        
        .text-headline {
            font-size: 17px;
            font-weight: 600;
            line-height: 1.29;
            letter-spacing: -0.43px;
        }
        
        .text-body {
            font-size: 17px;
            font-weight: 400;
            line-height: 1.47;
            letter-spacing: -0.43px;
        }
        
        .text-callout {
            font-size: 16px;
            font-weight: 400;
            line-height: 1.31;
            letter-spacing: -0.32px;
        }
        
        .text-subheadline {
            font-size: 15px;
            font-weight: 400;
            line-height: 1.33;
            letter-spacing: -0.24px;
        }
        
        .text-footnote {
            font-size: 13px;
            font-weight: 400;
            line-height: 1.38;
            letter-spacing: -0.08px;
        }
        
        .text-caption-1 {
            font-size: 12px;
            font-weight: 400;
            line-height: 1.33;
            letter-spacing: 0;
        }
        
        .text-caption-2 {
            font-size: 11px;
            font-weight: 400;
            line-height: 1.27;
            letter-spacing: 0.06px;
        }

        /* Add floating particles animation */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(59, 130, 246, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(234, 88, 12, 0.1) 0%, transparent 50%);
            animation: floatingParticles 20s ease-in-out infinite;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes floatingParticles {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(30px, -30px) rotate(120deg); }
            66% { transform: translate(-20px, 20px) rotate(240deg); }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Header Bar with Language Toggle */
        .top-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: saturate(180%) blur(20px);
            -webkit-backdrop-filter: saturate(180%) blur(20px);
            border-bottom: 0.5px solid rgba(60, 60, 67, 0.12);
            z-index: 1000;
            padding: 12px 20px;
            box-shadow: none;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }
        
        .brand-section {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }
        
        .brand-logo {
            font-size: 18px;
            font-weight: 600;
            color: var(--system-blue);
            text-decoration: none;
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            letter-spacing: -0.5px;
        }
        
        .brand-logo:hover {
            transform: scale(1.05);
        }
        
        .brand-links {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .brand-link {
            color: var(--system-blue);
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            padding: 6px 12px;
            border-radius: var(--radius-medium);
            background: var(--fill-quaternary);
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border: 0.5px solid transparent;
        }
        
        .brand-link:hover {
            background: var(--system-blue);
            color: white;
            transform: translateY(-0.5px);
            box-shadow: var(--shadow-2);
        }
        
        .controls-section {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .lang-toggle {
            background: var(--system-blue);
            color: white;
            border: none;
            border-radius: var(--radius-medium);
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: var(--shadow-1);
        }
        
        .lang-toggle:hover {
            background: #0056CC;
            transform: translateY(-0.5px);
            box-shadow: var(--shadow-3);
        }
        
        .lang-toggle:active {
            transform: translateY(0);
            box-shadow: var(--shadow-1);
        }

        .lecture-header {
            text-align: center;
            padding: 80px 40px;
            background: linear-gradient(135deg, var(--apple-blue) 0%, var(--apple-purple) 100%);
            border-radius: var(--radius-xl);
            margin: 40px 20px;
            box-shadow: var(--shadow-4);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .lecture-header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: headerGlow 8s linear infinite;
        }

        @keyframes headerFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes headerGlow {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .lecture-header h1 {
            font-size: 4rem;
            font-weight: 800;
            margin-bottom: 20px;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            z-index: 1;
            animation: titlePulse 4s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .lecture-header .subtitle {
            font-size: 1.5rem;
            color: rgba(255,255,255,0.95);
            margin-bottom: 30px;
            position: relative;
            z-index: 1;
        }

        .professor-attribution {
            background: rgba(255,255,255,0.15);
            padding: 25px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
            z-index: 1;
            transition: all 0.3s ease;
        }

        .professor-attribution:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        .professor-attribution h3 {
            color: white;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .section {
            background: var(--bg-primary);
            border-radius: var(--radius-large);
            padding: 40px;
            margin: 20px;
            border: 1px solid var(--gray-5);
            box-shadow: var(--shadow-2);
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .section:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-3);
            border-color: var(--gray-4);
        }

        @keyframes sectionSlideIn {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .section h2 {
            font-size: 2.8rem;
            font-weight: 700;
            background: var(--gradient-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid var(--border-accent);
            position: relative;
        }

        .section h2::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 60px;
            height: 3px;
            background: var(--gradient-accent);
            border-radius: 2px;
            animation: underlineGrow 2s ease-out;
        }

        @keyframes underlineGrow {
            from { width: 0; }
            to { width: 60px; }
        }

        .section h3 {
            font-size: 2rem;
            color: var(--primary-blue);
            margin: 30px 0 20px 0;
            font-weight: 600;
            position: relative;
            padding-left: 20px;
        }

        .section h3::before {
            content: '▶';
            position: absolute;
            left: 0;
            color: var(--accent-orange);
            animation: arrowBounce 2s ease-in-out infinite;
        }

        @keyframes arrowBounce {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(5px); }
        }

        .key-concept {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            border: 2px solid var(--primary-blue);
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            animation: conceptGlow 3s ease-in-out infinite alternate;
        }

        .key-concept::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: conceptShine 3s infinite;
        }

        @keyframes conceptGlow {
            from { box-shadow: 0 0 20px rgba(59, 130, 246, 0.2); }
            to { box-shadow: 0 0 30px rgba(59, 130, 246, 0.4); }
        }

        @keyframes conceptShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .key-concept h4 {
            color: var(--primary-blue);
            font-size: 1.5rem;
            margin-bottom: 15px;
            font-weight: 700;
            position: relative;
            z-index: 1;
        }

        .mathematical-explanation {
            background: var(--bg-accent);
            border: 2px solid var(--accent-purple);
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-medium);
        }

        .mathematical-explanation::before {
            content: '∫';
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 3rem;
            color: rgba(139, 92, 246, 0.1);
            z-index: 0;
        }

        .mathematical-explanation h4 {
            color: var(--accent-purple);
            margin-bottom: 15px;
            font-family: 'Inter', serif;
            font-weight: 700;
            position: relative;
            z-index: 1;
        }

        .demo-container {
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border-radius: 24px;
            padding: 40px;
            margin: 30px 0;
            border: 2px solid var(--border-light);
            box-shadow: var(--shadow-large);
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .demo-container::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: var(--gradient-primary);
            border-radius: 26px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .demo-container:hover {
            transform: translateY(-5px) scale(1.01);
            box-shadow: var(--shadow-xl);
        }

        .demo-container:hover::before {
            opacity: 1;
        }

        .demo-title {
            background: var(--gradient-accent);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 1.8rem;
            font-weight: 800;
            margin-bottom: 25px;
            text-align: center;
            position: relative;
            animation: titleShimmer 2s ease-in-out infinite;
        }

        @keyframes titleShimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        /* Enhanced Pixel Grid Animation */
        .pixel-demo {
            display: grid;
            grid-template-columns: repeat(16, 30px);
            gap: 3px;
            margin: 30px auto;
            justify-content: center;
            max-width: 550px;
            padding: 20px;
            background: rgba(59, 130, 246, 0.05);
            border-radius: 20px;
            border: 2px dashed var(--primary-blue);
        }

        .pixel {
            width: 30px;
            height: 30px;
            border: 2px solid var(--border-light);
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            position: relative;
            border-radius: 6px;
            background: #ffffff;
            box-shadow: var(--shadow-soft);
        }

        .pixel::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(59, 130, 246, 0.3) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }

        .pixel:hover {
            transform: scale(1.3) rotate(5deg);
            z-index: 10;
            box-shadow: 0 0 25px rgba(59, 130, 246, 0.4);
            border-color: var(--primary-blue);
        }

        .pixel:hover::before {
            width: 40px;
            height: 40px;
        }

        .pixel.active {
            animation: pixelPulse 1.5s infinite;
            border-color: var(--accent-orange);
        }

        @keyframes pixelPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 10px rgba(234, 88, 12, 0.3);
            }
            50% { 
                transform: scale(1.1);
                box-shadow: 0 0 20px rgba(234, 88, 12, 0.6);
            }
        }

        .pixel:active {
            transform: scale(0.9);
            transition: transform 0.1s ease;
        }

        /* Advanced Neural Network Visualization */
        .neural-network {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 40px;
            background: radial-gradient(circle, var(--bg-card) 0%, var(--bg-dark) 100%);
            border-radius: 20px;
            margin: 30px 0;
            position: relative;
        }

        .layer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .layer-title {
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 10px;
        }

        .neuron {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--deeplearning-purple) 0%, var(--cs50-blue) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            border: 3px solid transparent;
        }

        .neuron:hover {
            transform: scale(1.3);
            border-color: var(--accent-gold);
            box-shadow: 0 0 30px rgba(107, 70, 193, 0.8);
        }

        .neuron.activated {
            animation: neuronPulse 1.5s ease-in-out;
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--warning) 100%);
        }

        @keyframes neuronPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.4); }
        }

        .connection {
            width: 120px;
            height: 4px;
            background: var(--border-gray);
            position: relative;
            transition: all 0.5s ease;
        }

        .connection.active {
            background: linear-gradient(90deg, var(--accent-gold) 0%, var(--deeplearning-purple) 100%);
            animation: signalFlow 1s ease-in-out;
            box-shadow: 0 0 10px var(--accent-gold);
        }

        @keyframes signalFlow {
            0% { transform: scaleX(0); transform-origin: left; }
            100% { transform: scaleX(1); transform-origin: left; }
        }

        /* Advanced Diffusion Process Animation */
        .diffusion-container {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 30px auto;
            border-radius: 20px;
            overflow: hidden;
            border: 3px solid var(--deeplearning-purple);
        }

        .diffusion-image {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 400% 400%;
            animation: gradientShift 4s ease-in-out infinite;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .noise-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255,255,255,0.1) 1px, transparent 1px),
                radial-gradient(circle at 80% 20%, rgba(255,255,255,0.1) 1px, transparent 1px),
                radial-gradient(circle at 40% 40%, rgba(255,255,255,0.15) 1px, transparent 1px),
                linear-gradient(45deg, transparent 49%, rgba(255,255,255,0.05) 50%, transparent 51%);
            background-size: 20px 20px, 30px 30px, 25px 25px, 15px 15px;
            opacity: 1;
            transition: opacity 3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: noiseFlicker 0.1s infinite;
        }

        @keyframes noiseFlicker {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .diffusion-controls {
            text-align: center;
            margin: 20px 0;
        }

        .step-indicator {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            gap: 10px;
        }

        .step {
            width: 30px;
            height: 8px;
            background: var(--border-gray);
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .step.active {
            background: var(--accent-gold);
            animation: stepGlow 0.5s ease;
        }

        @keyframes stepGlow {
            from { transform: scaleY(1); }
            to { transform: scaleY(2); }
        }

        /* Advanced Attention Mechanism Visualization */
        .attention-matrix {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            max-width: 400px;
            margin: 20px auto;
            padding: 20px;
            background: var(--bg-dark);
            border-radius: 15px;
        }

        .attention-cell {
            aspect-ratio: 1;
            background: var(--bg-card);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .attention-cell:hover {
            background: var(--accent-gold);
            transform: scale(1.1);
        }

        .attention-cell.highlighted {
            background: linear-gradient(135deg, var(--deeplearning-purple), var(--accent-gold));
            animation: attentionPulse 1s ease-in-out;
        }

        @keyframes attentionPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* Interactive Training Calculator */
        .calculator-advanced {
            background: linear-gradient(135deg, var(--deeplearning-purple) 0%, var(--cs50-blue) 100%);
            border-radius: 20px;
            padding: 40px;
            margin: 30px 0;
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
        }

        .calculator-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }

        .input-group {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .input-group label {
            display: block;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: var(--text-white);
            font-size: 16px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            background: rgba(255,255,255,0.2);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
        }

        .btn-professor {
            background: var(--apple-blue);
            color: white;
            border: none;
            border-radius: var(--radius-medium);
            padding: 12px 24px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.23, 1, 0.32, 1);
            -webkit-font-smoothing: antialiased;
        }

        .btn-professor:hover {
            background: #0056CC;
            transform: translateY(-1px);
            box-shadow: var(--shadow-2);
        }

        .btn-professor:active {
            transform: translateY(0);
        }

        /* Enhanced canvas styling */
        canvas {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border: 2px solid var(--border-light);
            border-radius: 12px;
            box-shadow: var(--shadow-soft);
            transition: all 0.3s ease;
        }

        canvas:hover {
            box-shadow: var(--shadow-medium);
            border-color: var(--primary-blue);
        }

        /* Memory access animations */
        @keyframes memoryAccess {
            0%, 100% { transform: scale(1); }
            50% { 
                transform: scale(1.1); 
                background: var(--gradient-accent);
                box-shadow: 0 0 30px rgba(234, 88, 12, 0.6);
            }
        }

        .memory-access {
            animation: memoryAccess 1.2s ease-in-out;
        }

        @keyframes dataFlow {
            0% { 
                transform: translateX(-100%) scaleY(1); 
                opacity: 0;
            }
            50% {
                opacity: 1;
                transform: translateX(0%) scaleY(1.2);
            }
            100% { 
                transform: translateX(100%) scaleY(1); 
                opacity: 0;
            }
        }

        .data-flow {
            position: relative;
            overflow: hidden;
        }

        .data-flow::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.6), transparent);
            animation: dataFlow 2s ease-in-out;
            border-radius: inherit;
        }

        .calculation-result {
            background: rgba(5, 150, 105, 0.2);
            border: 2px solid var(--success);
            border-radius: 15px;
            padding: 25px;
            margin-top: 25px;
            animation: resultSlideIn 0.5s ease-out;
        }

        @keyframes resultSlideIn {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Code examples with syntax highlighting */
        .code-block {
            background: #1a1a2e;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            border-left: 5px solid var(--accent-gold);
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            position: relative;
        }

        .code-block::before {
            content: 'Python';
            position: absolute;
            top: 10px;
            right: 15px;
            background: var(--accent-gold);
            color: var(--bg-dark);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        .code-comment { color: #7c7c7c; }
        .code-keyword { color: #569cd6; }
        .code-string { color: #ce9178; }
        .code-function { color: #dcdcaa; }
        .code-number { color: #b5cea8; }

        /* Enhanced tooltips */
        .tooltip-enhanced {
            position: relative;
            cursor: help;
            color: var(--accent-gold);
            text-decoration: underline;
            text-decoration-style: dotted;
        }

        .tooltip-enhanced::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 120%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-dark);
            color: var(--text-white);
            padding: 12px 16px;
            border-radius: 10px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1000;
            border: 2px solid var(--accent-gold);
            font-size: 14px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        .tooltip-enhanced:hover::after {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-5px);
        }

        /* Progress indicators */
        .progress-container {
            background: rgba(255,255,255,0.1);
            border-radius: 25px;
            height: 12px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--deeplearning-purple) 0%, var(--accent-gold) 100%);
            border-radius: 25px;
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: progressShine 2s infinite;
        }

        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .lecture-header h1 { font-size: 2.5rem; }
            .section h2 { font-size: 2rem; }
            .section { padding: 25px; }
            .neural-network { flex-direction: column; gap: 20px; }
            .connection { width: 80px; height: 40px; }
        }

        /* Print styles */
        @media print {
            body { background: white; color: black; }
            .section { border: 1px solid #ccc; }
            .demo-container { display: none; }
        }

        .learning-objective {
            background: linear-gradient(135deg, rgba(5, 150, 105, 0.1) 0%, rgba(6, 182, 212, 0.1) 100%);
            border: 2px solid var(--success);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .learning-objective h4 {
            color: var(--success);
            margin-bottom: 15px;
        }

        .framework-architecture {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .architecture-component {
            background: var(--bg-dark);
            border: 2px solid var(--deeplearning-purple);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .architecture-component:hover {
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(107, 70, 193, 0.3);
            border-color: var(--accent-gold);
        }

        .quiz-container {
            background: linear-gradient(135deg, var(--cs50-blue) 0%, var(--deeplearning-purple) 100%);
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
        }

        .quiz-question {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .quiz-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .quiz-option {
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .quiz-option:hover {
            border-color: var(--accent-gold);
            background: rgba(245, 158, 11, 0.2);
        }

        .quiz-option.correct {
            border-color: var(--success);
            background: rgba(5, 150, 105, 0.3);
        }

        .quiz-option.incorrect {
            border-color: var(--error);
            background: rgba(220, 38, 38, 0.3);
        }

        /* Enhanced RGB Slider Styles */
        .rgb-slider-container {
            margin: 10px 0;
        }

        .rgb-slider-container input[type="range"] {
            width: 200px;
            height: 8px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            margin: 0 10px;
        }

        .rgb-slider-container input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-gold);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
        }

        /* Enhanced Transistor and Capacitor Styles */
        .transistor-pair {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border: 2px solid var(--border-light);
            box-shadow: var(--shadow-soft);
            position: relative;
            overflow: hidden;
        }

        .transistor-pair::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
            transition: all 0.3s ease;
        }

        .transistor-pair:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
            transform: translateY(-8px) scale(1.05);
            box-shadow: var(--shadow-large);
            border-color: var(--primary-blue);
        }

        .transistor-pair:hover::before {
            left: 100%;
        }

        .bit-label {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 8px;
            text-align: center;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .transistor {
            width: 35px;
            height: 24px;
            background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
            border-radius: 6px;
            margin-bottom: 6px;
            position: relative;
            transition: all 0.4s ease;
            border: 2px solid var(--border-accent);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .transistor.active {
            background: var(--gradient-accent);
            box-shadow: 
                0 0 20px rgba(234, 88, 12, 0.4),
                inset 0 2px 4px rgba(255,255,255,0.3);
            border-color: var(--accent-orange);
            animation: transistorGlow 1s ease-in-out infinite alternate;
        }

        @keyframes transistorGlow {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        .transistor::after {
            content: 'T';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: 800;
            color: var(--text-dark);
            text-shadow: 0 1px 2px rgba(255,255,255,0.8);
        }

        .transistor.active::after {
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .capacitor {
            width: 35px;
            height: 18px;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            border: 2px solid var(--border-accent);
            border-radius: 4px;
            margin-bottom: 6px;
            position: relative;
            transition: all 0.4s ease;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }

        .capacitor.charged {
            border-color: var(--accent-orange);
            background: linear-gradient(135deg, rgba(234, 88, 12, 0.2) 0%, rgba(249, 115, 22, 0.3) 100%);
            box-shadow: 
                inset 0 0 8px rgba(234, 88, 12, 0.3),
                0 0 15px rgba(234, 88, 12, 0.2);
            animation: capacitorCharge 2s ease-in-out infinite;
        }

        @keyframes capacitorCharge {
            0%, 100% { 
                box-shadow: 
                    inset 0 0 8px rgba(234, 88, 12, 0.3),
                    0 0 15px rgba(234, 88, 12, 0.2);
            }
            50% { 
                box-shadow: 
                    inset 0 0 12px rgba(234, 88, 12, 0.5),
                    0 0 25px rgba(234, 88, 12, 0.4);
            }
        }

        .capacitor::after {
            content: 'C';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: 800;
            color: var(--text-muted);
            text-shadow: 0 1px 1px rgba(255,255,255,0.8);
        }

        .capacitor.charged::after {
            color: var(--accent-orange);
            text-shadow: 0 1px 1px rgba(255,255,255,0.5);
        }

        .bit-value {
            font-size: 16px;
            font-weight: 800;
            color: var(--text-dark);
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--accent-purple) 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            animation: bitFlicker 2s ease-in-out infinite;
        }

        @keyframes bitFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* Enhanced Interactive Bit/Byte Components */
        .interactive-bit {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--accent-purple) 100%);
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: var(--shadow-medium);
            margin: 0 auto 15px auto;
            position: relative;
            overflow: hidden;
        }

        .interactive-bit::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: bitRotate 3s linear infinite;
        }

        @keyframes bitRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .interactive-bit:hover {
            transform: scale(1.2) rotate(10deg);
            box-shadow: var(--shadow-xl);
        }

        .bit-visual {
            font-size: 24px;
            font-weight: 800;
            color: white;
            z-index: 1;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .bit-description {
            font-size: 10px;
            color: rgba(255,255,255,0.8);
            z-index: 1;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .bit-explanation {
            background: rgba(59, 130, 246, 0.1);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid var(--primary-blue);
            font-size: 14px;
            color: var(--text-dark);
        }

        /* Nibble Container */
        .nibble-container {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .nibble-bit {
            width: 50px;
            height: 60px;
            background: linear-gradient(135deg, var(--accent-purple) 0%, var(--primary-blue) 100%);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-soft);
            position: relative;
        }

        .nibble-bit:hover {
            transform: translateY(-5px) scale(1.1);
            box-shadow: var(--shadow-large);
        }

        .nibble-bit .bit-visual {
            font-size: 18px;
            font-weight: 800;
            color: white;
            margin-bottom: 2px;
        }

        .bit-weight {
            font-size: 10px;
            color: rgba(255,255,255,0.7);
            font-weight: 600;
        }

        .nibble-value {
            background: rgba(139, 92, 246, 0.1);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid var(--accent-purple);
            font-size: 14px;
            color: var(--text-dark);
        }

        /* Byte Container */
        .byte-container {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .byte-nibble {
            display: flex;
            gap: 4px;
            padding: 8px;
            background: rgba(234, 88, 12, 0.1);
            border-radius: 12px;
            border: 1px solid var(--accent-orange);
        }

        .byte-bit {
            width: 35px;
            height: 35px;
            background: var(--gradient-accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 800;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-soft);
        }

        .byte-bit:hover {
            transform: scale(1.15) rotate(5deg);
            box-shadow: var(--shadow-medium);
        }

        .byte-bit.zero {
            background: linear-gradient(135deg, #cbd5e1 0%, #94a3b8 100%);
            color: var(--text-dark);
        }

        .byte-value {
            background: rgba(234, 88, 12, 0.1);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid var(--accent-orange);
            font-size: 14px;
            color: var(--text-dark);
        }

        /* Animation effects for bit manipulation */
        .bit-changing {
            animation: bitChange 0.6s ease-in-out;
        }

        @keyframes bitChange {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3) rotate(180deg); }
        }

        /* Apple-style Notification System */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-large);
            padding: 16px 20px;
            box-shadow: var(--glass-shadow);
            z-index: 1000;
            transform: translateX(400px);
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            max-width: 320px;
        }

        .notification.show {
            transform: translateX(0);
            opacity: 1;
        }

        .notification-content {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .notification-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
        }

        .notification-icon.success { background: var(--apple-green); color: white; }
        .notification-icon.info { background: var(--apple-blue); color: white; }
        .notification-icon.warning { background: var(--apple-orange); color: white; }
        .notification-icon.error { background: var(--apple-red); color: white; }

        .notification-text {
            flex: 1;
        }

        .notification-title {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .notification-message {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        /* Apple-style Modal System */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: var(--bg-primary);
            border-radius: var(--radius-large);
            box-shadow: var(--shadow-4);
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .modal-overlay.show .modal {
            transform: translate(-50%, -50%) scale(1);
        }

        .modal-header {
            padding: 24px 24px 16px 24px;
            text-align: center;
            border-bottom: 1px solid var(--gray-5);
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .modal-subtitle {
            font-size: 15px;
            color: var(--text-secondary);
        }

        .modal-content {
            padding: 20px 24px;
        }

        .modal-actions {
            padding: 16px 24px 24px 24px;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        /* Apple-style Buttons */
        .btn-apple {
            background: var(--apple-blue);
            color: white;
            border: none;
            border-radius: var(--radius-medium);
            padding: 12px 24px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.23, 1, 0.32, 1);
            -webkit-font-smoothing: antialiased;
        }

        .btn-apple:hover {
            background: #0056CC;
            transform: translateY(-1px);
            box-shadow: var(--shadow-2);
        }

        .btn-apple:active {
            transform: translateY(0);
        }

        .btn-apple.secondary {
            background: var(--fill-tertiary);
            color: var(--text-primary);
        }

        .btn-apple.secondary:hover {
            background: var(--fill-secondary);
        }

        .btn-apple.success { background: var(--apple-green); }
        .btn-apple.warning { background: var(--apple-orange); }
        .btn-apple.error { background: var(--apple-red); }

        /* Practice Questions Component */
        .practice-section {
            background: var(--bg-secondary);
            border-radius: var(--radius-large);
            padding: 32px;
            margin: 32px 20px;
            border: 1px solid var(--gray-4);
        }

        .practice-header {
            text-align: center;
            margin-bottom: 32px;
        }

        .practice-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .practice-subtitle {
            font-size: 17px;
            color: var(--text-secondary);
        }

        .question-card {
            background: var(--bg-primary);
            border-radius: var(--radius-medium);
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-1);
            border: 1px solid var(--gray-5);
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .question-card:hover {
            box-shadow: var(--shadow-2);
        }

        .question-number {
            display: inline-block;
            background: var(--apple-blue);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .question-text {
            font-size: 18px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .question-options {
            display: grid;
            gap: 12px;
        }

        .question-option {
            background: var(--fill-quaternary);
            border: 2px solid transparent;
            border-radius: var(--radius-medium);
            padding: 16px 20px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.23, 1, 0.32, 1);
            font-size: 16px;
            color: var(--text-primary);
        }

        .question-option:hover {
            background: var(--fill-tertiary);
            border-color: var(--gray-4);
        }

        .question-option.selected {
            background: rgba(0, 122, 255, 0.1);
            border-color: var(--apple-blue);
            color: var(--apple-blue);
        }

        .question-option.correct {
            background: rgba(52, 199, 89, 0.1);
            border-color: var(--apple-green);
            color: var(--apple-green);
        }

        .question-option.correct::after {
            content: ' ✓';
            color: var(--apple-green);
            font-weight: bold;
            margin-left: 8px;
        }

        .question-option.incorrect {
            background: rgba(255, 59, 48, 0.1);
            border-color: var(--apple-red);
            color: var(--apple-red);
        }

        .question-option.incorrect::after {
            content: ' ✗';
            color: var(--apple-red);
            font-weight: bold;
            margin-left: 8px;
        }

        .question-explanation {
            margin-top: 16px;
            padding: 16px;
            background: var(--fill-quaternary);
            border-radius: var(--radius-small);
            font-size: 15px;
            color: var(--text-secondary);
            display: none;
        }

        .question-explanation.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Canvas styling for noise demonstrations */
        canvas {
            background: var(--bg-dark);
            border-radius: 8px;
        }

        /* Advanced animations */
        @keyframes memoryAccess {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); background: var(--accent-gold); }
        }

        .memory-access {
            animation: memoryAccess 0.8s ease-in-out;
        }

        @keyframes dataFlow {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .data-flow {
            position: relative;
            overflow: hidden;
        }

        .data-flow::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(245, 158, 11, 0.5), transparent);
            animation: dataFlow 1.5s ease-in-out;
        }

        /* Apple-style Modal System */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-backdrop);
            backdrop-filter: blur(8px);
            display: none;
            z-index: 10000;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .modal-overlay.show {
            display: flex;
            opacity: 1;
        }

        .modal-content {
            background: var(--modal-glass);
            backdrop-filter: blur(20px);
            border-radius: var(--radius-xl);
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-4);
            max-width: 90%;
            max-height: 80%;
            width: 500px;
            overflow-y: auto;
            transform: scale(0.7) translateY(50px);
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .modal-overlay.show .modal-content {
            transform: scale(1) translateY(0);
        }

        .modal-header {
            padding: 24px 24px 0;
            border-bottom: none;
        }

        .modal-title {
            font-size: 22px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0 0 8px;
            text-align: center;
        }

        .modal-body {
            padding: 16px 24px;
            color: var(--text-secondary);
            line-height: 1.6;
            font-size: 15px;
            white-space: pre-line;
        }

        .modal-footer {
            padding: 0 24px 24px;
            display: flex;
            justify-content: center;
            gap: 12px;
        }

        .modal-close {
            background: var(--fill-tertiary);
            color: var(--text-primary);
            border: none;
            border-radius: var(--radius-medium);
            padding: 10px 20px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: var(--fill-secondary);
        }

        /* Apple-style Notification System */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--notification-glass);
            backdrop-filter: blur(20px);
            border-radius: var(--radius-large);
            border: 1px solid var(--glass-border);
            padding: 16px 20px;
            box-shadow: var(--shadow-3);
            z-index: 10001;
            max-width: 350px;
            transform: translateX(400px);
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            opacity: 0;
        }

        .notification.show {
            transform: translateX(0);
            opacity: 1;
        }

        .notification.success {
            border-left: 4px solid var(--notification-success);
        }

        .notification.error {
            border-left: 4px solid var(--notification-error);
        }

        .notification.info {
            border-left: 4px solid var(--notification-info);
        }

        .notification.warning {
            border-left: 4px solid var(--notification-warning);
        }

        .notification-title {
            font-weight: 700;
            font-size: 15px;
            margin-bottom: 4px;
            color: var(--text-primary);
        }

        .notification-message {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .notification-close {
            position: absolute;
            top: 8px;
            right: 12px;
            background: none;
            border: none;
            font-size: 18px;
            color: var(--text-tertiary);
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s ease;
        }

        .notification-close:hover {
            color: var(--text-primary);
        }
        
        /* Neural Network Animation Styles */
        .attention-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            max-width: 200px;
            margin: 0 auto;
        }
        
        .attention-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: transform 0.2s ease;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        .attention-cell:hover {
            transform: scale(1.1);
        }
        
        .step-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            margin: 8px 0;
            background: var(--bg-secondary);
            border-radius: var(--radius-medium);
            transition: all 0.3s ease;
        }
        
        .step-item:hover {
            background: var(--fill-tertiary);
            transform: translateX(4px);
        }
        
        .step-number {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--system-blue);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .step-text {
            font-size: 14px;
            color: var(--label-primary);
        }
        
        .neuron-ripple {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(52, 199, 89, 0.4);
            transform: translate(-50%, -50%) scale(0);
            animation: rippleEffect 1s ease-out;
        }
        
        @keyframes rippleEffect {
            to {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
        
        /* Fix dark text on dark background issues */
        .mathematical-explanation {
            background: var(--bg-secondary) !important;
            color: var(--label-primary) !important;
            border: 1px solid var(--gray-5);
        }
        
        .mathematical-explanation h4 {
            color: var(--label-primary) !important;
        }
        
        .demo-container {
            background: var(--bg-secondary);
            border: 1px solid var(--gray-5);
        }
        
        .demo-title {
            color: var(--label-primary) !important;
        }
        
        /* Fix section backgrounds for better contrast */
        .section {
            background: var(--bg-primary);
            border: 1px solid var(--gray-6);
            color: var(--label-primary);
        }
        
        .key-concept {
            background: var(--bg-secondary) !important;
            color: var(--label-primary) !important;
            border-left: 4px solid var(--system-blue) !important;
        }
        
        .key-concept h4 {
            color: var(--system-blue) !important;
        }
        
        /* Practice Questions - Fix contrast */
        .practice-section {
            background: var(--bg-primary);
            color: var(--label-primary);
        }
        
        .practice-title {
            color: var(--label-primary) !important;
        }
        
        .question-card {
            background: var(--bg-secondary);
            color: var(--label-primary);
            border: 1px solid var(--gray-5);
        }
        
        .question-text {
            color: var(--label-primary) !important;
        }
        
        /* Code blocks - improve readability */
        pre, code {
            background: var(--gray-6) !important;
            color: var(--label-primary) !important;
            border: 1px solid var(--gray-5);
        }
        
        /* Mobile Responsive Styles */\n        @media (max-width: 768px) {\n            body {\n                font-size: 15px;\n                padding-top: 120px;\n            }\n            \n            .top-header {\n                padding: 10px 15px;\n            }\n            \n            .header-content {\n                justify-content: center;\n                text-align: center;\n            }\n            \n            .brand-section {\n                width: 100%;\n                justify-content: center;\n            }\n            \n            .controls-section {\n                width: 100%;\n                justify-content: center;\n            }\n            \n            .container {\n                padding: 20px 15px;\n            }\n            \n            .lecture-header h1 {\n                font-size: 28px;\n            }\n            \n            .section {\n                padding: 20px;\n                margin: 15px 10px;\n            }\n            \n            .demo-container {\n                padding: 15px;\n            }\n            \n            .mathematical-explanation pre {\n                font-size: 12px;\n                overflow-x: auto;\n            }\n            \n            .pixel-demo {\n                grid-template-columns: repeat(8, 1fr);\n                gap: 2px;\n            }\n            \n            .pixel-box {\n                width: 35px;\n                height: 35px;\n            }\n            \n            .rgb-slider-container {\n                width: 100%;\n            }\n            \n            .rgb-slider-container input[type=\"range\"] {\n                width: 100%;\n            }\n            \n            .practice-section {\n                padding: 20px;\n                margin: 20px 10px;\n            }\n            \n            .modal-content {\n                width: 90%;\n                margin: 20px;\n            }\n            \n            .btn-professor, .btn-apple {\n                font-size: 14px;\n                padding: 10px 16px;\n                width: 100%;\n                margin: 5px 0;\n            }\n            \n            /* Stack buttons on mobile */\n            .demo-container > div[style*=\"display: flex\"] {\n                flex-direction: column;\n                align-items: stretch;\n            }\n            \n            /* Responsive tables */\n            table {\n                font-size: 12px;\n            }\n            \n            /* Responsive code blocks */\n            code {\n                font-size: 12px;\n            }\n        }\n        \n        @media (max-width: 480px) {\n            body {\n                font-size: 14px;\n            }\n            \n            .lecture-header h1 {\n                font-size: 24px;\n            }\n            \n            h2 {\n                font-size: 20px;\n            }\n            \n            h3 {\n                font-size: 18px;\n            }\n            \n            .pixel-demo {\n                grid-template-columns: repeat(5, 1fr);\n            }\n            \n            .pixel-box {\n                width: 28px;\n                height: 28px;\n            }\n            \n            .brand-logo {\n                font-size: 16px;\n            }\n            \n            .brand-link {\n                font-size: 12px;\n                padding: 4px 8px;\n            }\n        }\n        \n        /* RTL Specific Styles */\n        body.rtl .mathematical-explanation pre {\n            direction: ltr;\n            text-align: left;\n        }\n        \n        body.rtl .code-block {\n            direction: ltr;\n            text-align: left;\n        }\n        \n        body.rtl ul, body.rtl ol {\n            padding-right: 30px;\n            padding-left: 0;\n        }\n        \n        body.rtl .brand-links {\n            flex-direction: row-reverse;\n        }\n        \n        /* Hebrew Font Improvements */\n        body.rtl {\n            line-height: 1.8;\n        }\n        \n        body.rtl h1, body.rtl h2, body.rtl h3, body.rtl h4 {\n            font-weight: 700;\n            letter-spacing: 0;\n        }
    </style>
</head>
<body>
    <!-- Top Header with Links and Language Toggle -->
    <div class="top-header">
        <div class="header-content">
            <div class="brand-section">
                <a href="https://yuv.ai" target="_blank" rel="noopener" class="brand-logo">🤖 YUV.AI</a>
                <div class="brand-links">
                    <a href="https://yuv.ai" target="_blank" rel="noopener" class="brand-link">Website</a>
                    <a href="https://linktr.ee/yuvai" target="_blank" rel="noopener" class="brand-link">Links</a>
                </div>
            </div>
            <div class="controls-section">
                <button class="lang-toggle" onclick="toggleLanguage()" id="langToggle">
                    🌐 עברית
                </button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <!-- Lecture Introduction -->
        <div class="lecture-header">
            <h1>🎓 AI Image Generation</h1>
            <div class="subtitle">Complete Academic Course: From Mathematics to Implementation</div>
            <div class="professor-attribution">
                <h3>Course Instructor Style: Andrew Ng & David J. Malan</h3>
                <p><strong>Developed by:</strong> Yuval Avidani (YUV.AI) | <strong>X:</strong> @yuvalav | <strong>GitHub:</strong> @hoodini</p>
                <p><em>"The best way to learn is to understand the underlying principles, see them in action, and build upon them."</em></p>
            </div>
        </div>

        <!-- Course Overview and Prerequisites -->
        <div class="section" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 20px; padding: 30px; margin: 20px;">
            <h2 style="color: white; text-align: center; margin-bottom: 20px;">🚀 Welcome to the Future of AI Education</h2>
            <p style="text-align: center; font-size: 18px; margin-bottom: 25px; opacity: 0.9;">
                This isn't just another AI tutorial. This is a comprehensive journey from the mathematical bedrock of neural networks 
                to building production-ready AI image generation systems. Every concept builds upon the previous, creating a 
                rock-solid foundation for innovation.
            </p>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 25px 0;">
                <div style="background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px; backdrop-filter: blur(10px);">
                    <h4 style="color: #FFD700; margin-bottom: 10px;">🎯 Prerequisites</h4>
                    <ul style="list-style: none; padding: 0;">
                        <li>✓ Basic Python programming</li>
                        <li>✓ High school mathematics</li>
                        <li>✓ Curiosity about AI (most important!)</li>
                    </ul>
                </div>
                <div style="background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px; backdrop-filter: blur(10px);">
                    <h4 style="color: #FFD700; margin-bottom: 10px;">⏱️ Time Investment</h4>
                    <ul style="list-style: none; padding: 0;">
                        <li>📖 Reading: ~2 hours</li>
                        <li>🧪 Interactive Labs: ~3 hours</li>
                        <li>🧠 Practice Questions: ~1 hour</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Learning Objectives -->
        <div class="section">
            <h2>📚 Course Learning Objectives</h2>
            <div class="learning-objective">
                <h4>By the end of this course, you will master:</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 20px;">
                    <div style="background: var(--bg-secondary); border-left: 4px solid var(--apple-blue); padding: 20px; border-radius: 10px;">
                        <h5 style="color: var(--apple-blue); margin-bottom: 10px;">🧮 Mathematical Mastery</h5>
                        <p><strong>Understand</strong> the mathematical foundations: linear algebra, probability theory, and calculus behind neural networks</p>
                    </div>
                    <div style="background: var(--bg-secondary); border-left: 4px solid var(--apple-purple); padding: 20px; border-radius: 10px;">
                        <h5 style="color: var(--apple-purple); margin-bottom: 10px;">👁️ Architectural Vision</h5>
                        <p><strong>Visualize</strong> and comprehend transformer attention mechanisms, U-Net structures, and diffusion processes</p>
                    </div>
                    <div style="background: var(--bg-secondary); border-left: 4px solid var(--apple-green); padding: 20px; border-radius: 10px;">
                        <h5 style="color: var(--apple-green); margin-bottom: 10px;">🔬 Technical Analysis</h5>
                        <p><strong>Analyze</strong> FLUX innovations: Flow Matching, dual text encoders, and MMDiT architecture</p>
                    </div>
                    <div style="background: var(--bg-secondary); border-left: 4px solid var(--apple-orange); padding: 20px; border-radius: 10px;">
                        <h5 style="color: var(--apple-orange); margin-bottom: 10px;">⚡ Practical Implementation</h5>
                        <p><strong>Calculate</strong> optimal LoRA parameters and build your own training frameworks from scratch</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Lecture 1: Digital Image Fundamentals -->
        <div class="section">
            <h2>🔬 Lecture 1: Digital Image Fundamentals - "The Matrix Behind Every Image"</h2>
            
            <div style="background: linear-gradient(45deg, #f093fb 0%, #f5576c 100%); color: white; padding: 25px; border-radius: 15px; margin: 20px 0;">
                <h4 style="color: white; margin-bottom: 15px;">💡 Mind-Blowing Fact</h4>
                <p style="font-size: 18px; line-height: 1.8;">
                    Right now, as you read this, your computer is storing this text using the same mathematical principles 
                    that power DALL-E, Midjourney, and Stable Diffusion. Every pixel on your screen is a number, and every 
                    image is a matrix. <strong>AI doesn't see pictures—it sees mathematics.</strong>
                </p>
            </div>
            
            <div class="key-concept" style="border-left: 4px solid var(--apple-blue); background: var(--bg-secondary); padding: 25px; margin: 20px 0;">
                <h4 style="color: var(--apple-blue);">🎯 Core Principle: Everything is Numbers</h4>
                <p style="font-size: 16px; line-height: 1.7;">
                    When you look at the Mona Lisa, you see art. When a computer "looks" at the Mona Lisa, it sees exactly 
                    <strong>262,144 numbers</strong> arranged in a 512×512 grid. Each number represents how much red, green, and blue light 
                    should shine from that exact spot. This isn't an approximation—this IS the image in digital form.
                </p>
                
                <div style="background: rgba(0, 122, 255, 0.1); border-radius: 10px; padding: 15px; margin-top: 15px;">
                    <strong>Think about this:</strong> When FLUX generates an image of "a cat wearing sunglasses," it's actually 
                    performing 12 billion mathematical operations to predict the perfect number for each of those 262,144 positions. 
                    That's 3.14 trillion calculations for a single image!
                </div>
            </div>

            <h3 style="border-bottom: 2px solid var(--apple-purple); padding-bottom: 10px; color: var(--apple-purple);">1.1 The Anatomy of a Pixel - From Photons to Numbers</h3>
            
            <p style="font-size: 16px; line-height: 1.7; margin: 20px 0;">
                Let's start with first principles. A <span class="tooltip-enhanced" data-tooltip="Pixel = Picture Element. The atomic unit of digital imagery." 
                style="background: var(--apple-yellow); padding: 2px 6px; border-radius: 4px; color: black; font-weight: bold;">pixel</span> 
                is not just a colored square—it's a <strong>quantized measurement of electromagnetic radiation</strong> in the visible spectrum (380-750 nanometers).
            </p>
            
            <div style="background: var(--bg-secondary); border-radius: 15px; padding: 20px; margin: 20px 0;">
                <h4 style="color: var(--apple-green); margin-bottom: 15px;">🌈 The Journey from Light to Pixel</h4>
                <ol style="font-size: 15px; line-height: 1.6;">
                    <li><strong>Photons hit your camera sensor</strong> → Physical light energy</li>
                    <li><strong>Sensor converts to electrons</strong> → Analog electrical signal</li>
                    <li><strong>Analog-to-Digital Converter (ADC)</strong> → Quantized to 0-255 range</li>
                    <li><strong>RGB separation</strong> → Three numbers per pixel</li>
                    <li><strong>Matrix storage</strong> → Your digital image is born!</li>
                </ol>
                <p style="margin-top: 15px; font-style: italic; color: var(--text-secondary);">
                    This same process happens in reverse when AI generates images—it predicts the perfect numbers, 
                    then your display converts them back to photons your eyes can see.
                </p>
            </div>

            <div class="mathematical-explanation" style="background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); color: white; border-radius: 15px; padding: 25px;">
                <h4 style="color: #FFD700; margin-bottom: 20px;">🧮 Mathematical Foundation - The RGB Universe</h4>
                <div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 20px; font-family: 'Courier New', monospace;">
<pre style="color: #E6E6FA; margin: 0; font-size: 14px;"><code><span style="color: #98FB98;"># RGB Color Space - The Foundation of Digital Vision</span>
<span style="color: #FFB6C1;">pixel_value</span> = (<span style="color: #87CEEB;">R</span>, <span style="color: #87CEEB;">G</span>, <span style="color: #87CEEB;">B</span>)  <span style="color: #98FB98;"># Each: 0-255 (8 bits)</span>

<span style="color: #98FB98;"># The Mind-Blowing Scale:</span>
<span style="color: #FFB6C1;">total_colors</span> = <span style="color: #87CEEB;">256</span>³ = <span style="color: #FFD700;">16,777,216</span> <span style="color: #98FB98;">possible colors!</span>
<span style="color: #FFB6C1;">human_eye_can_see</span> = <span style="color: #87CEEB;">10,000,000</span> <span style="color: #98FB98;">colors (approximate)</span>

<span style="color: #98FB98;"># For a Full HD image (1920×1080):</span>
<span style="color: #FFB6C1;">total_pixels</span> = <span style="color: #87CEEB;">1920</span> × <span style="color: #87CEEB;">1080</span> = <span style="color: #FFD700;">2,073,600</span> pixels
<span style="color: #FFB6C1;">memory_required</span> = <span style="color: #87CEEB;">2,073,600</span> × <span style="color: #87CEEB;">3</span> bytes = <span style="color: #FFD700;">6.22 MB</span>

<span style="color: #98FB98;"># What FLUX.1-dev actually processes:</span>
<span style="color: #FFB6C1;">flux_typical</span> = <span style="color: #87CEEB;">1024</span> × <span style="color: #87CEEB;">1024</span> × <span style="color: #87CEEB;">3</span> = <span style="color: #FFD700;">3,145,728</span> numbers per image
<span style="color: #FFB6C1;">parameters</span> = <span style="color: #87CEEB;">12,000,000,000</span>  <span style="color: #98FB98;"># 12 billion weights!</span></code></pre>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); border-radius: 10px; padding: 15px; margin-top: 15px;">
                    <strong style="color: #FFD700;">💡 Professor's Insight:</strong> 
                    <span style="opacity: 0.9;">Notice that we can represent 16.7 million colors, but humans can only see about 10 million. 
                    This "extra" precision is crucial for AI training—it gives the neural network more granular control over 
                    color transitions, leading to smoother, more realistic images.</span>
                </div>
            </div>

            <div class="demo-container">
                <div class="demo-title">🎨 Interactive Pixel Matrix Laboratory</div>
                <p><strong>Experiment:</strong> Click on individual pixels to modify their RGB values. Observe how changing individual elements affects the overall image perception.</p>
                
                <div class="pixel-demo" id="pixelMatrix">
                    <!-- Pixels will be dynamically generated -->
                </div>
                
                <div style="display: flex; gap: 20px; justify-content: center; margin: 20px 0;">
                    <button class="btn-professor" onclick="createImagePattern()">Generate Pattern</button>
                    <button class="btn-professor" onclick="addNoiseToPixels()">Add Gaussian Noise</button>
                    <button class="btn-professor" onclick="clearPixelMatrix()">Reset Matrix</button>
                </div>
                
                <div id="pixelAnalysis" style="background: var(--bg-card); padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <strong>Current Analysis:</strong> Click on pixels above to see their RGB decomposition and mathematical representation.
                </div>
            </div>

            <h3>1.2 RGB Color Space Deep Dive</h3>
            <p>Before we proceed, let's understand exactly how computers represent color at the deepest level.</p>

            <div class="demo-container">
                <div class="demo-title">🔬 RGB Component Analyzer</div>
                <p><strong>Interactive Lab:</strong> Click on a pixel below to see its RGB decomposition and understand how three numbers create millions of colors.</p>
                
                <div style="display: flex; justify-content: space-around; align-items: center; margin: 30px 0;">
                    <div style="text-align: center;">
                        <div class="rgb-slider-container">
                            <label for="redSlider" style="color: #ff4444; font-weight: bold;">Red Channel (0-255):</label>
                            <input type="range" id="redSlider" min="0" max="255" value="128" 
                                   style="width: 200px; accent-color: #ff4444;" oninput="updateRGBDemo()">
                            <span id="redValue" style="color: #ff4444; font-weight: bold;">128</span>
                        </div>
                        <div class="rgb-slider-container" style="margin: 15px 0;">
                            <label for="greenSlider" style="color: #44ff44; font-weight: bold;">Green Channel (0-255):</label>
                            <input type="range" id="greenSlider" min="0" max="255" value="128" 
                                   style="width: 200px; accent-color: #44ff44;" oninput="updateRGBDemo()">
                            <span id="greenValue" style="color: #44ff44; font-weight: bold;">128</span>
                        </div>
                        <div class="rgb-slider-container">
                            <label for="blueSlider" style="color: #4444ff; font-weight: bold;">Blue Channel (0-255):</label>
                            <input type="range" id="blueSlider" min="0" max="255" value="128" 
                                   style="width: 200px; accent-color: #4444ff;" oninput="updateRGBDemo()">
                            <span id="blueValue" style="color: #4444ff; font-weight: bold;">128</span>
                        </div>
                    </div>
                    
                    <div style="text-align: center;">
                        <div id="rgbColorDisplay" style="width: 150px; height: 150px; border: 3px solid var(--accent-gold); border-radius: 15px; background: rgb(128, 128, 128);"></div>
                        <div style="margin-top: 15px; font-family: monospace; background: var(--bg-dark); padding: 15px; border-radius: 10px;">
                            <div><strong>RGB:</strong> <span id="rgbDisplay">(128, 128, 128)</span></div>
                            <div><strong>Hex:</strong> <span id="hexDisplay">#808080</span></div>
                            <div><strong>Binary:</strong></div>
                            <div style="font-size: 12px; color: var(--text-gray);">
                                R: <span id="redBinary">10000000</span><br>
                                G: <span id="greenBinary">10000000</span><br>
                                B: <span id="blueBinary">10000000</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="rgbAnalysis" style="background: var(--bg-card); padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <strong>Color Analysis:</strong> Each RGB channel is stored as 8 bits (1 byte) in computer memory. Total: 24 bits per pixel.
                </div>
            </div>

            <h3>1.3 Computer Memory at the Transistor Level</h3>
            <p>Let's understand exactly how these RGB values are stored in computer memory, down to the transistor level.</p>

            <div class="mathematical-explanation">
                <h4>Memory Hierarchy: From Transistors to Pixels</h4>
                <pre><code><span class="code-comment"># Memory storage hierarchy</span>
<span class="code-keyword">1 bit</span> = <span class="code-number">1</span> transistor + <span class="code-number">1</span> capacitor (in DRAM)
<span class="code-keyword">1 byte</span> = <span class="code-number">8</span> bits = <span class="code-number">8</span> transistors + <span class="code-number">8</span> capacitors
<span class="code-keyword">1 RGB pixel</span> = <span class="code-number">3</span> bytes = <span class="code-number">24</span> bits = <span class="code-number">24</span> transistors + <span class="code-number">24</span> capacitors

<span class="code-comment"># For a 1920×1080 image:</span>
<span class="code-keyword">total_pixels</span> = <span class="code-number">1920</span> × <span class="code-number">1080</span> = <span class="code-number">2,073,600</span>
<span class="code-keyword">total_transistors</span> = <span class="code-number">2,073,600</span> × <span class="code-number">24</span> = <span class="code-number">49,766,400</span> transistors!

<span class="code-comment"># Modern GPU memory (RTX 4090 with 24GB GDDR6X):</span>
<span class="code-keyword">total_bits</span> = <span class="code-number">24</span> × <span class="code-number">1024</span>³ × <span class="code-number">8</span> = <span class="code-number">206,158,430,208</span> bits
<span class="code-keyword">total_transistors</span> = ~<span class="code-number">206 billion</span> transistors storing your data!</code></pre>
            </div>

            <div class="demo-container">
                <div class="demo-title">⚡ Transistor-Level Memory Simulator</div>
                <p><strong>Deep Dive:</strong> Watch how a single pixel's RGB data is stored at the transistor level in computer memory.</p>
                
                <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 5px; max-width: 600px; margin: 20px auto; padding: 20px; background: var(--bg-dark); border-radius: 15px;">
                    <div style="grid-column: span 8; text-align: center; color: var(--accent-gold); font-weight: bold; margin-bottom: 15px;">
                        Red Channel (8 bits) - Binary: <span id="memoryRedBinary">10000000</span>
                    </div>
                    
                    <!-- 8 transistor-capacitor pairs for red channel -->
                    <div class="transistor-pair" onclick="toggleBit(this, 0)">
                        <div class="bit-label">Bit 7 (128)</div>
                        <div class="transistor active" data-bit="7"></div>
                        <div class="capacitor charged" data-bit="7"></div>
                        <div class="bit-value">1</div>
                    </div>
                    <div class="transistor-pair" onclick="toggleBit(this, 1)">
                        <div class="bit-label">Bit 6 (64)</div>
                        <div class="transistor" data-bit="6"></div>
                        <div class="capacitor" data-bit="6"></div>
                        <div class="bit-value">0</div>
                    </div>
                    <div class="transistor-pair" onclick="toggleBit(this, 2)">
                        <div class="bit-label">Bit 5 (32)</div>
                        <div class="transistor" data-bit="5"></div>
                        <div class="capacitor" data-bit="5"></div>
                        <div class="bit-value">0</div>
                    </div>
                    <div class="transistor-pair" onclick="toggleBit(this, 3)">
                        <div class="bit-label">Bit 4 (16)</div>
                        <div class="transistor" data-bit="4"></div>
                        <div class="capacitor" data-bit="4"></div>
                        <div class="bit-value">0</div>
                    </div>
                    <div class="transistor-pair" onclick="toggleBit(this, 4)">
                        <div class="bit-label">Bit 3 (8)</div>
                        <div class="transistor" data-bit="3"></div>
                        <div class="capacitor" data-bit="3"></div>
                        <div class="bit-value">0</div>
                    </div>
                    <div class="transistor-pair" onclick="toggleBit(this, 5)">
                        <div class="bit-label">Bit 2 (4)</div>
                        <div class="transistor" data-bit="2"></div>
                        <div class="capacitor" data-bit="2"></div>
                        <div class="bit-value">0</div>
                    </div>
                    <div class="transistor-pair" onclick="toggleBit(this, 6)">
                        <div class="bit-label">Bit 1 (2)</div>
                        <div class="transistor" data-bit="1"></div>
                        <div class="capacitor" data-bit="1"></div>
                        <div class="bit-value">0</div>
                    </div>
                    <div class="transistor-pair" onclick="toggleBit(this, 7)">
                        <div class="bit-label">Bit 0 (1)</div>
                        <div class="transistor" data-bit="0"></div>
                        <div class="capacitor" data-bit="0"></div>
                        <div class="bit-value">0</div>
                    </div>
                    
                    <div style="grid-column: span 8; text-align: center; margin-top: 20px; padding: 15px; background: var(--bg-card); border-radius: 10px;">
                        <strong>Current Red Value:</strong> <span id="currentRedValue">128</span> / 255<br>
                        <strong>Memory Address:</strong> 0x<span id="memoryAddress">7F800000</span><br>
                        <strong>Physical Reality:</strong> <span id="transistorCount">8</span> transistors storing this single byte
                    </div>
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <button class="btn-professor" onclick="demonstrateMemoryAccess()">🔄 Memory Read/Write</button>
                    <button class="btn-professor" onclick="showParameterMemory()">🤖 AI Parameters</button>
                    <button class="btn-professor" onclick="resetMemoryDemo()">🔄 Reset</button>
                </div>
            </div>

            <div class="demo-container">
                <div class="demo-title">🔥 Interactive Byte & Bit Playground</div>
                <p><strong>Advanced Simulation:</strong> Watch data flow through memory hierarchies and see how multiple bits combine to form bytes!</p>
                
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 30px; margin: 30px 0;">
                    <div style="text-align: center;">
                        <h4 style="color: var(--primary-blue); margin-bottom: 15px;">🟦 Single Bit</h4>
                        <div class="interactive-bit" id="singleBit" onclick="toggleSingleBit()">
                            <div class="bit-visual">0</div>
                            <div class="bit-description">Click to toggle!</div>
                        </div>
                        <div class="bit-explanation">
                            <strong>Physical Reality:</strong><br>
                            <span id="bitPhysics">1 transistor + 1 capacitor = 1 bit</span>
                        </div>
                    </div>
                    
                    <div style="text-align: center;">
                        <h4 style="color: var(--accent-purple); margin-bottom: 15px;">🟪 4-Bit Nibble</h4>
                        <div class="nibble-container">
                            <div class="nibble-bit" onclick="toggleNibbleBit(0)">
                                <div class="bit-visual">0</div>
                                <div class="bit-weight">8</div>
                            </div>
                            <div class="nibble-bit" onclick="toggleNibbleBit(1)">
                                <div class="bit-visual">0</div>
                                <div class="bit-weight">4</div>
                            </div>
                            <div class="nibble-bit" onclick="toggleNibbleBit(2)">
                                <div class="bit-visual">0</div>
                                <div class="bit-weight">2</div>
                            </div>
                            <div class="nibble-bit" onclick="toggleNibbleBit(3)">
                                <div class="bit-visual">0</div>
                                <div class="bit-weight">1</div>
                            </div>
                        </div>
                        <div class="nibble-value">
                            <strong>Decimal:</strong> <span id="nibbleValue">0</span><br>
                            <strong>Hex:</strong> <span id="nibbleHex">0</span>
                        </div>
                    </div>
                    
                    <div style="text-align: center;">
                        <h4 style="color: var(--accent-orange); margin-bottom: 15px;">🟧 Full Byte</h4>
                        <div class="byte-container">
                            <div class="byte-nibble">
                                <div class="byte-bit" onclick="toggleByteBit(0)">1</div>
                                <div class="byte-bit" onclick="toggleByteBit(1)">0</div>
                                <div class="byte-bit" onclick="toggleByteBit(2)">1</div>
                                <div class="byte-bit" onclick="toggleByteBit(3)">0</div>
                            </div>
                            <div class="byte-nibble">
                                <div class="byte-bit" onclick="toggleByteBit(4)">1</div>
                                <div class="byte-bit" onclick="toggleByteBit(5)">0</div>
                                <div class="byte-bit" onclick="toggleByteBit(6)">1</div>
                                <div class="byte-bit" onclick="toggleByteBit(7)">0</div>
                            </div>
                        </div>
                        <div class="byte-value">
                            <strong>Binary:</strong> <span id="byteValue">10101010</span><br>
                            <strong>Decimal:</strong> <span id="byteDecimal">170</span><br>
                            <strong>ASCII:</strong> <span id="byteAscii">ª</span>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(59, 130, 246, 0.05); border-radius: 15px; padding: 20px; margin: 30px 0; border: 2px dashed var(--primary-blue);">
                    <h4 style="color: var(--primary-blue); text-align: center; margin-bottom: 15px;">🧮 Real-Time Calculations</h4>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px;">
                        <div>
                            <strong>Memory Usage:</strong><br>
                            • Single bit: <span id="memoryBit">1 transistor</span><br>
                            • Nibble (4 bits): <span id="memoryNibble">4 transistors</span><br>
                            • Byte (8 bits): <span id="memoryByte">8 transistors</span>
                        </div>
                        <div>
                            <strong>Information Capacity:</strong><br>
                            • 1 bit: <span id="infoBit">2 possible values</span><br>
                            • 4 bits: <span id="infoNibble">16 possible values</span><br>
                            • 8 bits: <span id="infoByte">256 possible values</span>
                        </div>
                    </div>
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <button class="btn-professor" onclick="startByteAnimation()">🎬 Animate Data Flow</button>
                    <button class="btn-professor" onclick="randomizeBits()">🎲 Random Pattern</button>
                    <button class="btn-professor" onclick="resetBitDemo()">🔄 Reset All</button>
                </div>
            </div>

            <h3>1.4 From Pixels to Understanding</h3>
            <p>The challenge in AI image generation is not creating pixels—computers have always been able to generate random colored squares. The challenge is creating <em>meaningful</em> pixels that form coherent, semantically correct images.</p>

            <div class="key-concept">
                <h4>The Fundamental Problem</h4>
                <p>How do we teach a computer to generate the specific arrangement of millions of pixels that represents "a cat sitting on a windowsill during sunset"? This requires understanding semantics, spatial relationships, lighting physics, and artistic composition—all simultaneously.</p>
            </div>
        </div>

        <!-- Lecture 2: Neural Network Architecture -->
        <div class="section">
            <h2>🧠 Lecture 2: Neural Network Foundations</h2>

            <h3>2.1 The Perceptron: Building Block of Intelligence</h3>
            <p>Before we can understand advanced architectures like transformers, we must master the fundamental building block: the artificial neuron.</p>

            <div class="mathematical-explanation">
                <h4>Mathematical Model of a Neuron:</h4>
                <pre><code><span class="code-comment"># Weighted sum with bias</span>
<span class="code-keyword">z</span> = <span class="code-function">sum</span>(<span class="code-keyword">w_i</span> * <span class="code-keyword">x_i</span>) + <span class="code-keyword">b</span>

<span class="code-comment"># Activation function (sigmoid example)</span>
<span class="code-keyword">a</span> = <span class="code-number">1</span> / (<span class="code-number">1</span> + <span class="code-function">exp</span>(-<span class="code-keyword">z</span>))

<span class="code-comment"># Where:</span>
<span class="code-comment"># w_i = weight for input i</span>
<span class="code-comment"># x_i = input value i</span>
<span class="code-comment"># b = bias term</span>
<span class="code-comment"># a = neuron output (0 to 1)</span></code></pre>
            </div>

            <div class="demo-container">
                <div class="demo-title">🔄 Advanced Neural Network Simulator</div>
                <p><strong>Interactive Demonstration:</strong> Click on neurons to see signal propagation. Watch how information flows through layers and observe the mathematical transformations at each step.</p>
                
                <div class="neural-network" id="neuralNetwork">
                    <div class="layer">
                        <div class="layer-title">Input Layer</div>
                        <div class="neuron" onclick="activateNeuron(this, 'input', 0)" data-layer="input" data-index="0">x₁</div>
                        <div class="neuron" onclick="activateNeuron(this, 'input', 1)" data-layer="input" data-index="1">x₂</div>
                        <div class="neuron" onclick="activateNeuron(this, 'input', 2)" data-layer="input" data-index="2">x₃</div>
                    </div>
                    
                    <div class="connection" id="connection1"></div>
                    
                    <div class="layer">
                        <div class="layer-title">Hidden Layer</div>
                        <div class="neuron" onclick="activateNeuron(this, 'hidden', 0)" data-layer="hidden" data-index="0">h₁</div>
                        <div class="neuron" onclick="activateNeuron(this, 'hidden', 1)" data-layer="hidden" data-index="1">h₂</div>
                        <div class="neuron" onclick="activateNeuron(this, 'hidden', 2)" data-layer="hidden" data-index="2">h₃</div>
                        <div class="neuron" onclick="activateNeuron(this, 'hidden', 3)" data-layer="hidden" data-index="3">h₄</div>
                    </div>
                    
                    <div class="connection" id="connection2"></div>
                    
                    <div class="layer">
                        <div class="layer-title">Output Layer</div>
                        <div class="neuron" onclick="activateNeuron(this, 'output', 0)" data-layer="output" data-index="0">ŷ₁</div>
                        <div class="neuron" onclick="activateNeuron(this, 'output', 1)" data-layer="output" data-index="1">ŷ₂</div>
                    </div>
                </div>
                
                <div id="neuralNetworkAnalysis" style="background: var(--bg-card); padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <strong>Network Analysis:</strong> Click on any neuron to see its mathematical computation and how it affects downstream neurons.
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <button class="btn-professor" onclick="forwardPropagate()">Forward Propagation</button>
                    <button class="btn-professor" onclick="resetNetwork()">Reset Network</button>
                </div>
            </div>

            <h3>2.2 Deep Networks: The Power of Composition</h3>
            <p>The magic of deep learning lies in <span class="tooltip-enhanced" data-tooltip="Function composition: f(g(h(x))) where each layer learns increasingly complex features">function composition</span>. Each layer learns to detect features of increasing complexity:</p>

            <div class="key-concept">
                <h4>Hierarchical Feature Learning</h4>
                <ul style="margin: 15px 0 0 30px;">
                    <li><strong>Layer 1:</strong> Detects edges, corners, basic shapes</li>
                    <li><strong>Layer 2:</strong> Combines edges into textures, simple patterns</li>
                    <li><strong>Layer 3:</strong> Recognizes parts of objects (eyes, wheels, leaves)</li>
                    <li><strong>Layer 4:</strong> Identifies complete objects (faces, cars, trees)</li>
                    <li><strong>Layer 5+:</strong> Understands context, scenes, relationships</li>
                </ul>
            </div>

            <div class="code-block">
<span class="code-comment"># Simplified PyTorch Implementation</span>
<span class="code-keyword">import</span> torch.nn <span class="code-keyword">as</span> nn

<span class="code-keyword">class</span> <span class="code-function">SimpleNN</span>(<span class="code-function">nn.Module</span>):
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(<span class="code-keyword">self</span>):
        <span class="code-function">super()</span>.__init__()
        <span class="code-keyword">self</span>.layers = nn.Sequential(
            nn.Linear(<span class="code-number">784</span>, <span class="code-number">128</span>),    <span class="code-comment"># Input: 28×28 pixels</span>
            nn.ReLU(),                   <span class="code-comment"># Activation function</span>
            nn.Linear(<span class="code-number">128</span>, <span class="code-number">64</span>),     <span class="code-comment"># Hidden layer</span>
            nn.ReLU(),
            nn.Linear(<span class="code-number">64</span>, <span class="code-number">10</span>)       <span class="code-comment"># Output: 10 classes</span>
        )
    
    <span class="code-keyword">def</span> <span class="code-function">forward</span>(<span class="code-keyword">self</span>, x):
        <span class="code-keyword">return</span> <span class="code-keyword">self</span>.layers(x)
            </div>
        </div>

        <!-- Lecture 3: Diffusion Models - The Mathematical Foundation -->
        <div class="section">
            <h2>🌊 Lecture 3: Diffusion Models - Probabilistic Image Generation</h2>

            <h3>3.1 The Forward Diffusion Process</h3>
            <p>Diffusion models are based on a profound insight from physics: if we can model how structure degrades into noise, we can reverse this process to create structure from noise.</p>

            <div class="mathematical-explanation">
                <h4>Forward Process Mathematical Formulation:</h4>
                <pre><code><span class="code-comment"># Forward noising process</span>
<span class="code-keyword">q</span>(x_t | x_{t-1}) = <span class="code-function">Normal</span>(√(1-β_t) * x_{t-1}, β_t * I)

<span class="code-comment"># Where:</span>
<span class="code-comment"># x_0 = original clean image</span>
<span class="code-comment"># x_T = pure noise (T = 1000 steps typically)</span>
<span class="code-comment"># β_t = noise schedule parameter</span>

<span class="code-comment"># Closed form solution:</span>
<span class="code-keyword">x_t</span> = √(α̅_t) * x_0 + √(1-α̅_t) * ε
<span class="code-comment"># where ε ~ N(0,I) and α̅_t = ∏(1-β_s)</span></code></pre>
            </div>

            <div class="demo-container">
                <div class="demo-title">🔬 Diffusion Process Laboratory</div>
                <p><strong>Experiment:</strong> Observe the step-by-step transformation from a clean image to pure noise, then watch the reverse process reconstruct the image.</p>
                
                <div class="diffusion-container" id="diffusionContainer">
                    <div class="diffusion-image" id="diffusionImage">🎨</div>
                    <div class="noise-layer" id="noiseLayer"></div>
                </div>
                
                <div class="step-indicator" id="stepIndicator">
                    <!-- Steps will be dynamically generated -->
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <button class="btn-professor" onclick="startForwardDiffusion()">Forward Process (Add Noise)</button>
                    <button class="btn-professor" onclick="startReverseDiffusion()">Reverse Process (Denoise)</button>
                    <button class="btn-professor" onclick="resetDiffusion()">Reset</button>
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar" id="diffusionProgress" style="width: 0%;"></div>
                </div>
                
                <div id="diffusionAnalysis" style="background: var(--bg-card); padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <strong>Process Analysis:</strong> <span id="diffusionStatus">Click a button above to begin the diffusion experiment.</span>
                </div>
            </div>

            <h3>3.2 The Reverse Process: Learning to Denoise</h3>
            <p>The reverse process is where the magic happens. We train a neural network to predict and remove the noise that was added at each step.</p>

            <div class="key-concept">
                <h4>The Denoising Objective</h4>
                <p>We train a neural network ε_θ(x_t, t) to predict the noise that was added to create x_t from x_0. The loss function is surprisingly simple:</p>
                <div style="text-align: center; font-size: 1.2em; margin: 15px 0; color: var(--accent-gold);">
                    <strong>L = ||ε - ε_θ(√(α̅_t) * x_0 + √(1-α̅_t) * ε, t)||²</strong>
                </div>
            </div>

            <div class="code-block">
<span class="code-comment"># Simplified training loop for diffusion model</span>
<span class="code-keyword">def</span> <span class="code-function">train_step</span>(model, x_0, optimizer):
    <span class="code-comment"># Sample random timestep</span>
    t = torch.randint(<span class="code-number">0</span>, num_timesteps, (batch_size,))
    
    <span class="code-comment"># Sample noise</span>
    noise = torch.randn_like(x_0)
    
    <span class="code-comment"># Add noise to clean image</span>
    x_t = sqrt_alpha_bar[t] * x_0 + sqrt_one_minus_alpha_bar[t] * noise
    
    <span class="code-comment"># Predict noise</span>
    predicted_noise = model(x_t, t)
    
    <span class="code-comment"># Compute loss</span>
    loss = F.mse_loss(predicted_noise, noise)
    
    <span class="code-comment"># Backpropagate</span>
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()
            </div>

            <h3>3.3 The Critical Role of Gaussian Noise</h3>
            <p>You might wonder: <em>"Why Gaussian noise? Why not uniform noise? Why not just random pixels?"</em> This is a profound question that goes to the heart of probability theory and information theory.</p>

            <div class="key-concept">
                <h4>Why Gaussian Noise is Mathematically Essential</h4>
                <p>Gaussian (normal) distribution is not arbitrary—it's fundamental to the universe itself. Here's why we <strong>must</strong> use it:</p>
                <ol style="margin: 15px 0 0 30px;">
                    <li><strong>Central Limit Theorem:</strong> Sum of many random variables → Gaussian distribution</li>
                    <li><strong>Maximum Entropy:</strong> Gaussian has highest entropy for given mean and variance</li>
                    <li><strong>Differentiability:</strong> Smooth gradients essential for neural network training</li>
                    <li><strong>Rotational Invariance:</strong> No preferred direction in noise space</li>
                    <li><strong>Mathematical Tractability:</strong> Gaussian + Gaussian = Gaussian (closure property)</li>
                </ol>
            </div>

            <div class="mathematical-explanation">
                <h4>Gaussian Distribution Mathematical Foundation:</h4>
                <pre><code><span class="code-comment"># Gaussian probability density function</span>
p(x) = (1/√(2πσ²)) * exp(-(x-μ)²/(2σ²))

<span class="code-comment"># For standard normal (μ=0, σ=1):</span>
p(x) = (1/√(2π)) * exp(-x²/2)

<span class="code-comment"># Why this matters in diffusion:</span>
<span class="code-keyword">If</span> X ~ N(0, I) <span class="code-keyword">and</span> Y ~ N(0, I)
<span class="code-keyword">Then</span> aX + bY ~ N(0, (a² + b²)I)

<span class="code-comment"># This property makes the math work out perfectly!</span>
<span class="code-keyword">clean_image</span> + <span class="code-keyword">gaussian_noise</span> = <span class="code-keyword">tractable_distribution</span></code></pre>
            </div>

            <div class="demo-container">
                <div class="demo-title">🎲 Noise Distribution Comparison Lab</div>
                <p><strong>Scientific Experiment:</strong> See why Gaussian noise is superior to other types of noise for diffusion models.</p>
                
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 30px 0;">
                    <div style="text-align: center;">
                        <h4 style="color: var(--error);">❌ Uniform Noise</h4>
                        <canvas id="uniformNoiseCanvas" width="200" height="200" style="border: 2px solid var(--error); border-radius: 10px;"></canvas>
                        <p style="margin-top: 10px; font-size: 14px;">Random values between 0-1</p>
                        <div style="background: var(--bg-card); padding: 10px; margin-top: 10px; border-radius: 8px;">
                            <strong>Problems:</strong><br>
                            • Sharp edges (non-differentiable)<br>
                            • No central tendency<br>
                            • Poor gradient flow
                        </div>
                    </div>
                    
                    <div style="text-align: center;">
                        <h4 style="color: var(--warning);">⚠️ Salt & Pepper Noise</h4>
                        <canvas id="saltPepperCanvas" width="200" height="200" style="border: 2px solid var(--warning); border-radius: 10px;"></canvas>
                        <p style="margin-top: 10px; font-size: 14px;">Random black/white pixels</p>
                        <div style="background: var(--bg-card); padding: 10px; margin-top: 10px; border-radius: 8px;">
                            <strong>Problems:</strong><br>
                            • Discrete jumps<br>
                            • No gradual transition<br>
                            • Training instability
                        </div>
                    </div>
                    
                    <div style="text-align: center;">
                        <h4 style="color: var(--success);">✅ Gaussian Noise</h4>
                        <canvas id="gaussianNoiseCanvas" width="200" height="200" style="border: 2px solid var(--success); border-radius: 10px;"></canvas>
                        <p style="margin-top: 10px; font-size: 14px;">Normal distribution N(0,1)</p>
                        <div style="background: var(--bg-card); padding: 10px; margin-top: 10px; border-radius: 8px;">
                            <strong>Advantages:</strong><br>
                            • Smooth everywhere<br>
                            • Differentiable<br>
                            • Mathematically elegant
                        </div>
                    </div>
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <button class="btn-professor" onclick="generateNoiseComparison()">Generate New Noise Samples</button>
                    <button class="btn-professor" onclick="showNoiseHistograms()">Show Statistical Distributions</button>
                    <button class="btn-professor" onclick="demonstrateGradientFlow()">Demonstrate Gradient Flow</button>
                </div>
                
                <div id="noiseAnalysis" style="background: var(--bg-card); padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <strong>Statistical Analysis:</strong> Click the buttons above to see why Gaussian noise is mathematically superior for training neural networks.
                </div>
            </div>

            <h3>3.4 Why We Cannot Use Other Types of Noise</h3>
            <p>Let's understand at a deep mathematical level why alternatives to Gaussian noise fail catastrophically in diffusion models:</p>

            <div class="mathematical-explanation">
                <h4>The Mathematics of Why Other Noise Types Fail:</h4>
                <pre><code><span class="code-comment"># Problem 1: Non-differentiability</span>
<span class="code-keyword">uniform_noise</span>: f(x) = 1/(b-a) <span class="code-keyword">if</span> a ≤ x ≤ b, <span class="code-keyword">else</span> 0
<span class="code-comment"># Sharp cutoffs → undefined derivatives → gradient explosion</span>

<span class="code-comment"># Problem 2: Non-additive properties</span>
<span class="code-keyword">If</span> X ~ Uniform(0,1) <span class="code-keyword">and</span> Y ~ Uniform(0,1)
<span class="code-keyword">Then</span> X + Y ~ Triangular distribution (NOT uniform!)
<span class="code-comment"># Math breaks down in diffusion forward process</span>

<span class="code-comment"># Problem 3: Infinite variance issues</span>
<span class="code-keyword">laplace_noise</span>: Heavy tails → E[X²] may not exist
<span class="code-comment"># Numerical instability in training</span>

<span class="code-comment"># Problem 4: Lack of rotational symmetry</span>
<span class="code-keyword">uniform_noise</span>: Prefers axis-aligned directions
<span class="code-comment"># Introduces artificial bias in image generation</span></code></pre>
            </div>

            <div class="key-concept">
                <h4>The Fundamental Theorem of Diffusion Models</h4>
                <p>The success of diffusion models relies on this mathematical fact:</p>
                <div style="text-align: center; font-size: 1.2em; margin: 20px 0; padding: 20px; background: rgba(107, 70, 193, 0.1); border-radius: 15px; border: 2px solid var(--deeplearning-purple);">
                    <strong>If p_data and p_noise are both Gaussian-like, then the interpolation path between them is mathematically tractable and the reverse process can be learned efficiently by a neural network.</strong>
                </div>
                <p>This is why DDPM, DDIM, and FLUX all use Gaussian noise—it's not a choice, it's a mathematical necessity!</p>
            </div>

            <div class="demo-container">
                <div class="demo-title">🧪 Advanced Noise Properties Laboratory</div>
                <p><strong>Deep Mathematical Investigation:</strong> Explore the properties that make Gaussian noise uniquely suited for diffusion models.</p>
                
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 30px; margin: 30px 0;">
                    <div style="background: var(--bg-dark); padding: 20px; border-radius: 15px; border: 2px solid var(--deeplearning-purple);">
                        <h4 style="color: var(--accent-gold); margin-bottom: 15px;">Property 1: Closure Under Addition</h4>
                        <canvas id="closureDemo" width="300" height="200" style="width: 100%; border-radius: 8px;"></canvas>
                        <p style="margin-top: 10px; font-size: 14px;">Gaussian + Gaussian = Gaussian (this is crucial for the math to work!)</p>
                        <button class="btn-professor" onclick="demonstrateClosure()" style="margin-top: 10px; font-size: 14px; padding: 8px 16px;">Demo Addition</button>
                    </div>
                    
                    <div style="background: var(--bg-dark); padding: 20px; border-radius: 15px; border: 2px solid var(--deeplearning-purple);">
                        <h4 style="color: var(--accent-gold); margin-bottom: 15px;">Property 2: Smooth Gradients</h4>
                        <canvas id="gradientDemo" width="300" height="200" style="width: 100%; border-radius: 8px;"></canvas>
                        <p style="margin-top: 10px; font-size: 14px;">Gaussian noise produces smooth, trainable gradients everywhere</p>
                        <button class="btn-professor" onclick="demonstrateGradients()" style="margin-top: 10px; font-size: 14px; padding: 8px 16px;">Show Gradients</button>
                    </div>
                    
                    <div style="background: var(--bg-dark); padding: 20px; border-radius: 15px; border: 2px solid var(--deeplearning-purple);">
                        <h4 style="color: var(--accent-gold); margin-bottom: 15px;">Property 3: Maximum Entropy</h4>
                        <div id="entropyDemo" style="height: 200px; display: flex; align-items: center; justify-content: center; flex-direction: column; border: 2px solid var(--border-gray); border-radius: 8px;">
                            <div style="font-size: 24px; margin-bottom: 10px;">H(Gaussian) = ½log(2πeσ²)</div>
                            <div style="font-size: 16px; color: var(--text-gray);">Maximum possible entropy for given variance</div>
                            <div id="entropyValue" style="margin-top: 15px; font-size: 18px; color: var(--accent-gold);">Entropy: 2.45 bits</div>
                        </div>
                        <button class="btn-professor" onclick="calculateEntropy()" style="margin-top: 10px; font-size: 14px; padding: 8px 16px;">Calculate</button>
                    </div>
                    
                    <div style="background: var(--bg-dark); padding: 20px; border-radius: 15px; border: 2px solid var(--deeplearning-purple);">
                        <h4 style="color: var(--accent-gold); margin-bottom: 15px;">Property 4: Rotational Invariance</h4>
                        <canvas id="rotationDemo" width="300" height="200" style="width: 100%; border-radius: 8px;"></canvas>
                        <p style="margin-top: 10px; font-size: 14px;">No preferred direction - essential for unbiased image generation</p>
                        <button class="btn-professor" onclick="demonstrateRotation()" style="margin-top: 10px; font-size: 14px; padding: 8px 16px;">Rotate View</button>
                    </div>
                </div>
                
                <div id="advancedNoiseAnalysis" style="background: var(--bg-card); padding: 25px; border-radius: 15px; margin-top: 20px; border: 2px solid var(--success);">
                    <h4 style="color: var(--success); margin-bottom: 15px;">🎯 Mathematical Conclusion</h4>
                    <p><strong>Gaussian noise is not just preferred—it's mathematically required for diffusion models to work.</strong> Any other choice breaks the mathematical foundations that make the reverse process learnable.</p>
                    
                    <div style="margin-top: 20px; padding: 15px; background: rgba(5, 150, 105, 0.1); border-radius: 10px;">
                        <strong>Key Insight:</strong> The reason FLUX, DDPM, and all successful diffusion models use Gaussian noise is that it's the only distribution that maintains mathematical consistency throughout the entire forward and reverse processes while providing smooth, trainable gradients for neural networks.
                    </div>
                </div>
            </div>
        </div>

        <!-- Lecture 4: Transformer Architecture and Attention -->
        <div class="section">
            <h2>🔄 Lecture 4: Transformer Architecture - The Attention Revolution</h2>

            <h3>4.1 The Attention Mechanism</h3>
            <p>The transformer architecture revolutionized AI by solving the fundamental problem of <span class="tooltip-enhanced" data-tooltip="Sequential processing limitation: RNNs process tokens one by one, making parallelization impossible">sequential bottlenecks</span> in neural networks through the attention mechanism.</p>

            <div class="mathematical-explanation">
                <h4>Self-Attention Mathematical Foundation:</h4>
                <pre><code><span class="code-comment"># Query, Key, Value computation</span>
Q = X @ W_q    <span class="code-comment"># Query matrix</span>
K = X @ W_k    <span class="code-comment"># Key matrix</span>
V = X @ W_v    <span class="code-comment"># Value matrix</span>

<span class="code-comment"># Scaled dot-product attention</span>
Attention(Q,K,V) = softmax(Q @ K^T / √d_k) @ V

<span class="code-comment"># Where:</span>
<span class="code-comment"># d_k = dimension of key vectors (for scaling)</span>
<span class="code-comment"># softmax ensures attention weights sum to 1</span></code></pre>
            </div>

            <div class="demo-container">
                <div class="demo-title">👁️ Attention Mechanism Visualizer</div>
                <p><strong>Interactive Demo:</strong> Click on different positions to see how attention weights distribute across the sequence.</p>
                
                <div style="text-align: center; margin: 20px 0;">
                    <div style="background: var(--bg-card); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                        <strong>Input Sentence:</strong> "A fluffy white cat sits gracefully on the windowsill"
                    </div>
                </div>
                
                <div class="attention-matrix" id="attentionMatrix">
                    <!-- Attention cells will be dynamically generated -->
                </div>
                
                <div id="attentionExplanation" style="background: var(--bg-card); padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <strong>Attention Analysis:</strong> Click on the matrix above to see how different words attend to each other.
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <button class="btn-professor" onclick="showAttentionPattern('subject')">Focus on Subject</button>
                    <button class="btn-professor" onclick="showAttentionPattern('verb')">Focus on Action</button>
                    <button class="btn-professor" onclick="showAttentionPattern('location')">Focus on Location</button>
                    <button class="btn-professor" onclick="resetAttention()">Reset</button>
                </div>
            </div>

            <h3>4.2 Multi-Head Attention: Parallel Processing Power</h3>
            <p>Multi-head attention allows the model to attend to different aspects of the input simultaneously, dramatically increasing the model's representational capacity.</p>

            <div class="key-concept">
                <h4>Why Multi-Head Attention Works</h4>
                <p>Different attention heads can specialize in different types of relationships:</p>
                <ul style="margin: 15px 0 0 30px;">
                    <li><strong>Head 1:</strong> Syntactic relationships (subject-verb agreement)</li>
                    <li><strong>Head 2:</strong> Semantic relationships (word meanings)</li>
                    <li><strong>Head 3:</strong> Positional relationships (spatial arrangements)</li>
                    <li><strong>Head 4:</strong> Long-range dependencies (document structure)</li>
                </ul>
            </div>

            <div class="code-block">
<span class="code-comment"># Multi-Head Attention Implementation</span>
<span class="code-keyword">class</span> <span class="code-function">MultiHeadAttention</span>(<span class="code-function">nn.Module</span>):
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(<span class="code-keyword">self</span>, d_model, num_heads):
        <span class="code-function">super()</span>.__init__()
        <span class="code-keyword">self</span>.num_heads = num_heads
        <span class="code-keyword">self</span>.d_k = d_model // num_heads
        
        <span class="code-keyword">self</span>.W_q = nn.Linear(d_model, d_model)
        <span class="code-keyword">self</span>.W_k = nn.Linear(d_model, d_model)
        <span class="code-keyword">self</span>.W_v = nn.Linear(d_model, d_model)
        <span class="code-keyword">self</span>.W_o = nn.Linear(d_model, d_model)
    
    <span class="code-keyword">def</span> <span class="code-function">forward</span>(<span class="code-keyword">self</span>, x):
        Q = <span class="code-keyword">self</span>.W_q(x).view(batch_size, seq_len, <span class="code-keyword">self</span>.num_heads, <span class="code-keyword">self</span>.d_k)
        K = <span class="code-keyword">self</span>.W_k(x).view(batch_size, seq_len, <span class="code-keyword">self</span>.num_heads, <span class="code-keyword">self</span>.d_k)
        V = <span class="code-keyword">self</span>.W_v(x).view(batch_size, seq_len, <span class="code-keyword">self</span>.num_heads, <span class="code-keyword">self</span>.d_k)
        
        <span class="code-comment"># Parallel attention computation across all heads</span>
        attention_output = scaled_dot_product_attention(Q, K, V)
        
        <span class="code-comment"># Concatenate heads and apply final projection</span>
        output = attention_output.view(batch_size, seq_len, d_model)
        <span class="code-keyword">return</span> <span class="code-keyword">self</span>.W_o(output)
            </div>
        </div>

        <!-- Lecture 5: FLUX Architecture -->
        <div class="section">
            <h2>⚡ Lecture 5: FLUX - Next Generation Diffusion Architecture</h2>

            <h3>5.1 Architectural Innovations</h3>
            <p>FLUX represents a significant evolution in diffusion model architecture, incorporating several key innovations that address fundamental limitations of previous approaches.</p>

            <div class="framework-architecture">
                <div class="architecture-component" onclick="explainComponent('flowmatching')">
                    <h4>🌊 Flow Matching</h4>
                    <p>Continuous-time diffusion process that provides smoother, more stable training dynamics.</p>
                </div>
                <div class="architecture-component" onclick="explainComponent('dualencoder')">
                    <h4>📝 Dual Text Encoders</h4>
                    <p>T5-XXL + CLIP for superior text understanding and image-text alignment.</p>
                </div>
                <div class="architecture-component" onclick="explainComponent('mmdit')">
                    <h4>🏗️ MMDiT Architecture</h4>
                    <p>Multimodal Diffusion Transformer that processes text and image tokens jointly.</p>
                </div>
                <div class="architecture-component" onclick="explainComponent('guidance')">
                    <h4>🎯 Guidance-Free Training</h4>
                    <p>Eliminates classifier-free guidance artifacts while maintaining controllability.</p>
                </div>
            </div>

            <div id="componentExplanation" style="background: var(--bg-card); padding: 25px; border-radius: 15px; margin-top: 20px; min-height: 150px;">
                <strong>Architecture Deep Dive:</strong> Click on any component above to learn about its mathematical foundation and implementation details.
            </div>

            <h3>5.2 Flow Matching vs Traditional Diffusion</h3>
            <p>Flow matching provides a more direct path from noise to image, reducing the number of sampling steps required and improving image quality.</p>

            <div class="mathematical-explanation">
                <h4>Flow Matching Mathematical Framework:</h4>
                <pre><code><span class="code-comment"># Traditional DDPM sampling requires many steps</span>
<span class="code-keyword">for</span> t <span class="code-keyword">in</span> <span class="code-function">range</span>(<span class="code-number">1000</span>, <span class="code-number">0</span>, -<span class="code-number">1</span>):
    x_t = denoise_step(x_t, t)  <span class="code-comment"># 1000 forward passes</span>

<span class="code-comment"># Flow matching: continuous-time formulation</span>
<span class="code-keyword">def</span> <span class="code-function">flow_matching</span>(x_noise, t):
    <span class="code-comment"># Direct interpolation between noise and data</span>
    <span class="code-keyword">return</span> (<span class="code-number">1</span> - t) * x_noise + t * x_data

<span class="code-comment"># Fewer sampling steps needed (typically 20-50 vs 1000)</span></code></pre>
            </div>

            <div class="key-concept">
                <h4>FLUX Performance Advantages</h4>
                <ul style="margin: 15px 0 0 30px;">
                    <li><strong>Speed:</strong> 20-50 sampling steps vs 1000 for DDPM</li>
                    <li><strong>Quality:</strong> Better fine detail preservation and coherence</li>
                    <li><strong>Text Adherence:</strong> Superior prompt following through dual encoders</li>
                    <li><strong>Efficiency:</strong> Lower memory usage during inference</li>
                    <li><strong>Stability:</strong> More robust training process with flow matching</li>
                </ul>
            </div>
        </div>

        <!-- Lecture 6: LoRA - Low Rank Adaptation -->
        <div class="section">
            <h2>🎯 Lecture 6: LoRA - Efficient Model Adaptation</h2>

            <h3>6.1 The Mathematical Foundation of LoRA</h3>
            <p>LoRA is based on the hypothesis that the weight updates during adaptation have a low intrinsic rank. This allows us to approximate the full weight matrix update with two smaller matrices.</p>

            <div class="mathematical-explanation">
                <h4>Low-Rank Decomposition:</h4>
                <pre><code><span class="code-comment"># Traditional fine-tuning updates entire weight matrix</span>
W_new = W_original + ΔW    <span class="code-comment"># ΔW is d×d (millions of parameters)</span>

<span class="code-comment"># LoRA approximation using rank decomposition</span>
ΔW ≈ A @ B    <span class="code-comment"># A is d×r, B is r×d where r << d</span>

<span class="code-comment"># For FLUX with d=4096, r=16:</span>
<span class="code-comment"># Full update: 4096×4096 = 16.7M parameters</span>
<span class="code-comment"># LoRA update: 4096×16 + 16×4096 = 131K parameters (99.2% reduction!)</span>

<span class="code-keyword">forward</span>(x) = W_original @ x + (A @ B) @ x</code></pre>
            </div>

            <div class="demo-container">
                <div class="demo-title">📊 LoRA Efficiency Calculator</div>
                <div class="calculator-advanced">
                    <h3 style="text-align: center; margin-bottom: 30px;">Professional Training Parameters Calculator</h3>
                    <div class="calculator-grid">
                        <div class="input-group">
                            <label for="trainingImages">Training Images:</label>
                            <input type="number" id="trainingImages" value="50" min="1" max="10000" onchange="updateCalculations()">
                            <small style="color: var(--text-gray); margin-top: 5px; display: block;">Recommended: 10-200 for character, 20-500 for style</small>
                        </div>

                        <div class="input-group">
                            <label for="loraRank">LoRA Rank (r):</label>
                            <input type="number" id="loraRank" value="16" min="1" max="128" onchange="updateCalculations()">
                            <small style="color: var(--text-gray); margin-top: 5px; display: block;">Higher rank = more capacity, but risk of overfitting</small>
                        </div>

                        <div class="input-group">
                            <label for="learningRate">Learning Rate:</label>
                            <input type="number" id="learningRate" value="0.0001" step="0.00001" min="0.00001" max="0.01" onchange="updateCalculations()">
                            <small style="color: var(--text-gray); margin-top: 5px; display: block;">Typical range: 1e-5 to 1e-3</small>
                        </div>

                        <div class="input-group">
                            <label for="trainingType">Training Objective:</label>
                            <select id="trainingType" onchange="updateCalculations()">
                                <option value="character">Character/Person (specific identity)</option>
                                <option value="style">Art Style (artistic technique)</option>
                                <option value="concept">Concept/Object (general category)</option>
                                <option value="photorealism">Photorealism Enhancement</option>
                            </select>
                        </div>

                        <div class="input-group">
                            <label for="dataQuality">Data Quality:</label>
                            <select id="dataQuality" onchange="updateCalculations()">
                                <option value="high">High (professional, consistent)</option>
                                <option value="medium">Medium (varied but good)</option>
                                <option value="mixed">Mixed (some low quality)</option>
                            </select>
                        </div>

                        <div class="input-group">
                            <label for="gpuMemory">Available GPU Memory (GB):</label>
                            <select id="gpuMemory" onchange="updateCalculations()">
                                <option value="12">12GB (RTX 3080/4070)</option>
                                <option value="16">16GB (RTX 4060 Ti)</option>
                                <option value="24">24GB (RTX 3090/4090)</option>
                                <option value="48">48GB (A6000)</option>
                                <option value="80">80GB (A100)</option>
                            </select>
                        </div>
                    </div>

                    <div style="text-align: center; margin: 30px 0;">
                        <button class="btn-professor" onclick="calculateOptimalParameters()">Calculate Optimal Training Parameters</button>
                    </div>

                    <div id="calculatorResults" style="display: none;" class="calculation-result">
                        <!-- Results will be populated here -->
                    </div>
                </div>
            </div>

            <h3>6.2 Advanced LoRA Configurations</h3>
            <p>Different LoRA configurations optimize for different objectives. Understanding these trade-offs is crucial for successful training.</p>

            <div class="framework-architecture">
                <div class="architecture-component">
                    <h4>👤 Character LoRA</h4>
                    <p><strong>Rank:</strong> 16-32<br>
                    <strong>Steps:</strong> 1500-3000<br>
                    <strong>Focus:</strong> Identity preservation</p>
                </div>
                <div class="architecture-component">
                    <h4>🎨 Style LoRA</h4>
                    <p><strong>Rank:</strong> 8-16<br>
                    <strong>Steps:</strong> 2000-4000<br>
                    <strong>Focus:</strong> Artistic technique</p>
                </div>
                <div class="architecture-component">
                    <h4>💡 Concept LoRA</h4>
                    <p><strong>Rank:</strong> 32-64<br>
                    <strong>Steps:</strong> 3000-5000<br>
                    <strong>Focus:</strong> Object understanding</p>
                </div>
            </div>
        </div>

        <!-- Lecture 7: Framework Architecture -->
        <div class="section">
            <h2>🏗️ Lecture 7: Building AI Training Frameworks</h2>

            <h3>7.1 AI-Toolkit Architecture Analysis</h3>
            <p>Ostris designed AI-Toolkit with several architectural principles that make it both powerful and accessible:</p>

            <div class="key-concept">
                <h4>Design Principles</h4>
                <ol style="margin: 15px 0 0 30px;">
                    <li><strong>Modularity:</strong> Extension-based system for easy customization</li>
                    <li><strong>Memory Efficiency:</strong> Gradient checkpointing and quantization</li>
                    <li><strong>Accessibility:</strong> YAML configuration files instead of code</li>
                    <li><strong>Flexibility:</strong> Support for multiple model architectures</li>
                    <li><strong>Monitoring:</strong> Built-in sampling and validation during training</li>
                </ol>
            </div>

            <div class="code-block">
<span class="code-comment"># AI-Toolkit Job System Architecture</span>
<span class="code-keyword">class</span> <span class="code-function">Job</span>:
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(<span class="code-keyword">self</span>, config_path):
        <span class="code-keyword">self</span>.config = load_yaml(config_path)
        <span class="code-keyword">self</span>.process = <span class="code-keyword">self</span>.get_process()
    
    <span class="code-keyword">def</span> <span class="code-function">get_process</span>(<span class="code-keyword">self</span>):
        <span class="code-comment"># Dynamically load the appropriate training process</span>
        process_type = <span class="code-keyword">self</span>.config[<span class="code-string">'process'</span>][<span class="code-string">'type'</span>]
        <span class="code-keyword">return</span> ExtensionManager.get_process(process_type)
    
    <span class="code-keyword">def</span> <span class="code-function">run</span>(<span class="code-keyword">self</span>):
        <span class="code-keyword">self</span>.process.train(<span class="code-keyword">self</span>.config)

<span class="code-comment"># Extension system allows easy customization</span>
<span class="code-keyword">class</span> <span class="code-function">SDTrainerExtension</span>(<span class="code-function">Extension</span>):
    uid = <span class="code-string">"sd_trainer"</span>
    name = <span class="code-string">"Stable Diffusion Trainer"</span>
    
    <span class="code-keyword">@classmethod</span>
    <span class="code-keyword">def</span> <span class="code-function">get_process</span>(<span class="code-keyword">cls</span>):
        <span class="code-keyword">from</span> .SDTrainer <span class="code-keyword">import</span> SDTrainer
        <span class="code-keyword">return</span> SDTrainer
            </div>

            <h3>7.2 Memory Optimization Strategies</h3>
            <p>One of the most critical aspects of making large model training accessible is memory optimization:</p>

            <div class="mathematical-explanation">
                <h4>Memory Usage Breakdown for FLUX Training:</h4>
                <pre><code><span class="code-comment"># Without optimization (typical 80GB+ requirement):</span>
Model Parameters: <span class="code-number">12B</span> × <span class="code-number">4</span> bytes (fp32) = <span class="code-number">48GB</span>
Gradients: <span class="code-number">12B</span> × <span class="code-number">4</span> bytes = <span class="code-number">48GB</span>
Optimizer States: <span class="code-number">12B</span> × <span class="code-number">8</span> bytes (Adam) = <span class="code-number">96GB</span>
Activations: ~<span class="code-number">20GB</span> (depends on batch size)
Total: ~<span class="code-number">210GB</span>

<span class="code-comment"># With AI-Toolkit optimizations:</span>
Model (8-bit): <span class="code-number">12B</span> × <span class="code-number">1</span> byte = <span class="code-number">12GB</span>
LoRA params: <span class="code-number">67M</span> × <span class="code-number">4</span> bytes = <span class="code-number">268MB</span>
Gradients: <span class="code-number">67M</span> × <span class="code-number">4</span> bytes = <span class="code-number">268MB</span>
Optimizer: <span class="code-number">67M</span> × <span class="code-number">8</span> bytes = <span class="code-number">536MB</span>
Activations (checkpointed): ~<span class="code-number">8GB</span>
Total: ~<span class="code-number">21GB</span> (90% reduction!)</code></pre>
            </div>
        </div>

        <!-- Interactive Quiz Section -->
        <div class="section">
            <h2>🎓 Knowledge Assessment</h2>
            <div class="quiz-container">
                <h3 style="text-align: center; margin-bottom: 30px;">Test Your Understanding</h3>
                
                <div class="quiz-question">
                    <h4>Question 1: Mathematical Foundation</h4>
                    <p>What is the primary mathematical principle that makes LoRA training efficient?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="selectQuizOption(this, false)">
                            Gradient clipping reduces memory usage
                        </div>
                        <div class="quiz-option" onclick="selectQuizOption(this, false)">
                            Batch normalization stabilizes training
                        </div>
                        <div class="quiz-option" onclick="selectQuizOption(this, true)">
                            Low-rank decomposition reduces parameter count
                        </div>
                        <div class="quiz-option" onclick="selectQuizOption(this, false)">
                            Attention mechanism focuses on important features
                        </div>
                    </div>
                </div>

                <div class="quiz-question">
                    <h4>Question 2: Practical Application</h4>
                    <p>For training a character LoRA with 30 high-quality images, what would be optimal?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="selectQuizOption(this, false)">
                            Rank=64, 5000 steps, LR=1e-3
                        </div>
                        <div class="quiz-option" onclick="selectQuizOption(this, true)">
                            Rank=16, 2000 steps, LR=1e-4
                        </div>
                        <div class="quiz-option" onclick="selectQuizOption(this, false)">
                            Rank=4, 500 steps, LR=1e-5
                        </div>
                        <div class="quiz-option" onclick="selectQuizOption(this, false)">
                            Rank=128, 10000 steps, LR=1e-2
                        </div>
                    </div>
                </div>

                <div id="quizResults" style="display: none; background: var(--success); color: white; padding: 20px; border-radius: 10px; margin-top: 20px; text-align: center;">
                    <h4>🎉 Assessment Complete!</h4>
                    <p>You've demonstrated understanding of the core concepts. Ready to build your own AI training frameworks!</p>
                </div>
            </div>
        </div>

        <!-- Practice Questions -->
        <div class="practice-section">
            <div class="practice-header">
                <h2 class="practice-title">🧠 Practice Questions</h2>
                <p class="practice-subtitle">Test your understanding with interactive questions</p>
            </div>
            
            <div class="question-card">
                <div class="question-number">1</div>
                <div class="question-text">What is the fundamental reason why diffusion models use Gaussian noise instead of uniform noise?</div>
                <div class="question-options">
                    <div class="question-option" onclick="selectAnswer(this, 1, 'A', false)">
                        A) Gaussian noise looks more natural to humans
                    </div>
                    <div class="question-option" onclick="selectAnswer(this, 1, 'B', false)">
                        B) Gaussian noise requires less computational power
                    </div>
                    <div class="question-option" onclick="selectAnswer(this, 1, 'C', true)">
                        C) Gaussian noise has smooth derivatives everywhere, enabling stable gradient-based training
                    </div>
                    <div class="question-option" onclick="selectAnswer(this, 1, 'D', false)">
                        D) Gaussian noise compresses better than uniform noise
                    </div>
                </div>
                <div class="question-explanation" id="explanation-1">
                    <strong>Correct!</strong> Gaussian noise is mathematically essential because it provides smooth, continuous derivatives everywhere. This is crucial for neural network training through backpropagation. Uniform noise has sharp cutoffs that create undefined derivatives, leading to training instability.
                </div>
            </div>

            <div class="question-card">
                <div class="question-number">2</div>
                <div class="question-text">How much memory does a single RGB pixel require at the transistor level?</div>
                <div class="question-options">
                    <div class="question-option" onclick="selectAnswer(this, 2, 'A', false)">
                        A) 8 transistors (1 byte)
                    </div>
                    <div class="question-option" onclick="selectAnswer(this, 2, 'B', true)">
                        B) 24 transistors (3 bytes for RGB)
                    </div>
                    <div class="question-option" onclick="selectAnswer(this, 2, 'C', false)">
                        C) 32 transistors (4 bytes with alpha channel)
                    </div>
                    <div class="question-option" onclick="selectAnswer(this, 2, 'D', false)">
                        D) 16 transistors (2 bytes)
                    </div>
                </div>
                <div class="question-explanation" id="explanation-2">
                    <strong>Excellent!</strong> Each RGB pixel requires 3 bytes (Red + Green + Blue channels). Each byte = 8 bits = 8 transistors + 8 capacitors in DRAM. Total: 24 transistors per pixel. This scales massively - a 1920×1080 image requires ~50 million transistors just to store!
                </div>
            </div>

            <div class="question-card">
                <div class="question-number">3</div>
                <div class="question-text">What makes LoRA training so much more efficient than full model fine-tuning?</div>
                <div class="question-options">
                    <div class="question-option" onclick="selectAnswer(this, 3, 'A', false)">
                        A) LoRA uses a different optimizer algorithm
                    </div>
                    <div class="question-option" onclick="selectAnswer(this, 3, 'B', true)">
                        B) LoRA approximates weight updates using low-rank decomposition, training only ~0.008% of parameters
                    </div>
                    <div class="question-option" onclick="selectAnswer(this, 3, 'C', false)">
                        C) LoRA runs on CPU instead of GPU
                    </div>
                    <div class="question-option" onclick="selectAnswer(this, 3, 'D', false)">
                        D) LoRA uses quantized weights
                    </div>
                </div>
                <div class="question-explanation" id="explanation-3">
                    <strong>Perfect!</strong> LoRA's key insight is that weight updates during adaptation have low intrinsic rank. Instead of updating all 12 billion parameters in FLUX, LoRA trains only ~1 million new parameters by decomposing ΔW ≈ A @ B where A and B are much smaller matrices. This reduces training by 99.2% while maintaining quality!
                </div>
            </div>

            <div class="question-card">
                <div class="question-number">4</div>
                <div class="question-text">Why does FLUX use dual text encoders (CLIP + T5-XXL) instead of a single encoder?</div>
                <div class="question-options">
                    <div class="question-option" onclick="selectAnswer(this, 4, 'A', true)">
                        A) CLIP provides visual-semantic alignment while T5-XXL offers deep language understanding
                    </div>
                    <div class="question-option" onclick="selectAnswer(this, 4, 'B', false)">
                        B) Two encoders process text faster than one
                    </div>
                    <div class="question-option" onclick="selectAnswer(this, 4, 'C', false)">
                        C) It's a backup system in case one encoder fails
                    </div>
                    <div class="question-option" onclick="selectAnswer(this, 4, 'D', false)">
                        D) Dual encoders reduce hallucinations
                    </div>
                </div>
                <div class="question-explanation" id="explanation-4">
                    <strong>Brilliant!</strong> FLUX combines complementary strengths: CLIP excels at understanding visual concepts and their relationship to text (77 token limit), while T5-XXL provides sophisticated language understanding with much longer context (512 tokens). Together, they enable superior text-to-image alignment and complex prompt comprehension.
                </div>
            </div>
        </div>

        <!-- Enhanced Final Summary -->
        <div class="section" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 20px; padding: 35px; margin: 40px 20px;">
            <h2 style="color: white; text-align: center; margin-bottom: 25px;">🎯 🎓 Congratulations - You're Now an AI Expert!</h2>
            
            <div style="text-align: center; margin-bottom: 30px; padding: 20px; background: rgba(255,255,255,0.1); border-radius: 15px;">
                <p style="font-size: 20px; margin-bottom: 15px; font-weight: bold;">
                    "From Zero to AI Hero - You've Mastered 12 Billion Parameters!"
                </p>
                <p style="opacity: 0.9; font-size: 16px;">
                    You started with pixels and numbers. You now understand the mathematics that powers 
                    the world's most advanced AI image generation systems. This knowledge puts you in the top 1% 
                    of AI practitioners globally.
                </p>
            </div>
            
            <div class="learning-objective">
                <h4 style="color: #FFD700; text-align: center; margin-bottom: 25px;">🏆 Your New Superpowers</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 25px;">
                    <div style="background: rgba(255,255,255,0.15); border-radius: 15px; padding: 25px; backdrop-filter: blur(10px);">
                        <h4 style="color: #FFD700; margin-bottom: 15px;">🧮 Mathematical Mastery</h4>
                        <ul style="list-style: none; padding: 0; line-height: 1.8;">
                            <li>✅ Neural network forward & back propagation</li>
                            <li>✅ Diffusion process mathematics (DDPM → Flow Matching)</li>
                            <li>✅ Attention mechanism equations (Q, K, V matrices)</li>
                            <li>✅ Low-rank decomposition theory (LoRA mathematics)</li>
                            <li>✅ Gaussian noise theory and differentiability</li>
                        </ul>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.15); border-radius: 15px; padding: 25px; backdrop-filter: blur(10px);">
                        <h4 style="color: #FFD700; margin-bottom: 15px;">🔧 Engineering Excellence</h4>
                        <ul style="list-style: none; padding: 0; line-height: 1.8;">
                            <li>✅ Training parameter optimization (steps, LR, batch size)</li>
                            <li>✅ Memory usage calculations (transistor-level understanding)</li>
                            <li>✅ Architecture design principles (FLUX vs Stable Diffusion)</li>
                            <li>✅ Framework development (AI-Toolkit analysis)</li>
                            <li>✅ Performance debugging and scaling</li>
                        </ul>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.15); border-radius: 15px; padding: 25px; backdrop-filter: blur(10px);">
                        <h4 style="color: #FFD700; margin-bottom: 15px;">🚀 Innovation Readiness</h4>
                        <ul style="list-style: none; padding: 0; line-height: 1.8;">
                            <li>✅ Build custom training frameworks</li>
                            <li>✅ Design novel architectures</li>
                            <li>✅ Optimize for specific hardware</li>
                            <li>✅ Debug training failures professionally</li>
                            <li>✅ Contribute to open-source projects</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 35px; padding: 25px; background: rgba(255,255,255,0.1); border-radius: 15px; text-align: center;">
                <h4 style="color: #FFD700; margin-bottom: 20px;">🌟 Your AI Journey Continues</h4>
                <p style="margin-bottom: 25px; font-size: 16px; line-height: 1.7;">
                    You're now equipped with the knowledge used by researchers at OpenAI, Google DeepMind, and Anthropic. 
                    The next breakthrough in AI could come from you.
                </p>
                
                <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                    <a href="https://yuv.ai" target="_blank" rel="noopener" 
                       style="background: #FFD700; color: #333; padding: 15px 30px; border-radius: 12px; text-decoration: none; 
                              font-weight: bold; transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                        🤖 Explore YUV.AI
                    </a>
                    <a href="https://linktr.ee/yuvai" target="_blank" rel="noopener"
                       style="background: rgba(255,255,255,0.2); color: white; padding: 15px 30px; border-radius: 12px; 
                              text-decoration: none; font-weight: bold; border: 2px solid white; transition: all 0.3s ease;
                              display: flex; align-items: center; gap: 8px;">
                        🔗 Connect & Learn More
                    </a>
                </div>
                
                <p style="margin-top: 25px; font-style: italic; opacity: 0.8;">
                    "The best time to plant a tree was 20 years ago. The second best time is now." <br>
                    Your AI expertise tree has been planted. Now watch it grow! 🌳
                </p>
            </div>
        </div>
                    <div class="architecture-component">
                        <h4>🚀 Advanced Concepts</h4>
                        <ul style="text-align: left; margin-top: 10px;">
                            <li>FLUX architecture innovations</li>
                            <li>Framework development</li>
                            <li>Optimization strategies</li>
                            <li>Research directions</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="key-concept">
                <h4>Your Next Learning Path</h4>
                <ol style="margin: 15px 0 0 30px;">
                    <li><strong>Hands-on Practice:</strong> Train your first LoRA using AI-Toolkit</li>
                    <li><strong>Experiment:</strong> Try different architectures and parameters</li>
                    <li><strong>Contribute:</strong> Join open-source AI training projects</li>
                    <li><strong>Research:</strong> Read latest papers on diffusion models and attention</li>
                    <li><strong>Build:</strong> Create your own specialized training framework</li>
                </ol>
            </div>

            <div style="text-align: center; margin: 40px 0;">
                <button class="btn-professor" onclick="celebrateCompletion()" style="font-size: 24px; padding: 20px 40px;">
                    🎊 Complete Your AI Journey! 🎊
                </button>
            </div>
        </div>
    </div>

    <script>
        // Global variables for interactive demos
        let diffusionStep = 0;
        let maxDiffusionSteps = 20;
        let isForwardProcess = true;
        let quizScore = 0;
        let totalQuestions = 2;

        // Initialize all interactive elements
        document.addEventListener('DOMContentLoaded', function() {
            initializePixelMatrix();
            initializeStepIndicator();
            initializeAttentionMatrix();
            updateCalculations();
        });

        // Pixel Matrix Functions
        function initializePixelMatrix() {
            const matrix = document.getElementById('pixelMatrix');
            matrix.innerHTML = '';
            
            for (let i = 0; i < 256; i++) {
                const pixel = document.createElement('div');
                pixel.className = 'pixel';
                pixel.style.backgroundColor = `hsl(${Math.random() * 60 + 200}, 50%, 25%)`;
                pixel.onclick = () => analyzePixel(pixel, i);
                matrix.appendChild(pixel);
            }
        }

        function analyzePixel(pixel, index) {
            const row = Math.floor(index / 16);
            const col = index % 16;
            const rgb = window.getComputedStyle(pixel).backgroundColor;
            
            document.getElementById('pixelAnalysis').innerHTML = `
                <strong>Pixel Analysis:</strong><br>
                <strong>Position:</strong> Row ${row}, Column ${col} (Index: ${index})<br>
                <strong>Color:</strong> ${rgb}<br>
                <strong>Mathematical Representation:</strong> Matrix[${row}][${col}]<br>
                <strong>Memory Address:</strong> Base + ${index * 3} bytes (RGB)
            `;
            
            pixel.classList.add('active');
            setTimeout(() => pixel.classList.remove('active'), 2000);
        }

        function createImagePattern() {
            const pixels = document.querySelectorAll('.pixel');
            pixels.forEach((pixel, index) => {
                const row = Math.floor(index / 16);
                const col = index % 16;
                const hue = (row * col * 5) % 360;
                pixel.style.backgroundColor = `hsl(${hue}, 70%, 50%)`;
            });
        }

        function addNoiseToPixels() {
            const pixels = document.querySelectorAll('.pixel-box');
            if (pixels.length === 0) {
                // Fallback: create pixels if they don't exist
                initializePixelMatrix();
                setTimeout(() => addNoiseToPixels(), 100);
                return;
            }
            
            pixels.forEach((pixel, index) => {
                // Add Gaussian noise effect with animation
                setTimeout(() => {
                    const noise = gaussianRandom(0.8, 0.2); // Mean 0.8, std 0.2
                    const currentBg = window.getComputedStyle(pixel).backgroundColor;
                    
                    // Parse RGB values
                    const rgb = currentBg.match(/\\d+/g);
                    if (rgb && rgb.length >= 3) {
                        const r = Math.max(0, Math.min(255, parseInt(rgb[0]) * noise));
                        const g = Math.max(0, Math.min(255, parseInt(rgb[1]) * noise));
                        const b = Math.max(0, Math.min(255, parseInt(rgb[2]) * noise));
                        
                        pixel.style.backgroundColor = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
                        pixel.style.transform = 'scale(1.1)';
                        
                        setTimeout(() => {
                            pixel.style.transform = 'scale(1)';
                        }, 150);
                    }
                }, index * 50);
            });
            
            // Show success notification
            const t = translations[currentLanguage] || translations['en'];
            showNotification('🌀 Gaussian Noise Applied!', 'Watch how noise affects each pixel differently - this is how AI learns!', 'success');
        }

        function clearPixelMatrix() {
            const pixels = document.querySelectorAll('.pixel-box');
            pixels.forEach((pixel, index) => {
                setTimeout(() => {
                    pixel.style.backgroundColor = `hsl(${220 + index * 3}, 20%, 30%)`;
                    pixel.style.filter = 'none';
                    pixel.style.transform = 'scale(0.95)';
                    
                    setTimeout(() => {
                        pixel.style.transform = 'scale(1)';
                    }, 150);
                }, index * 20);
            });
        }
        
        // Gaussian random number generator (Box-Muller transform)
        function gaussianRandom(mean = 0, std = 1) {
            const u = 1 - Math.random(); // Converting [0,1) to (0,1]
            const v = Math.random();
            const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            return z * std + mean;
        }

        // Neural Network Animation System
        function initializeStepIndicator() {
            // Initialize step-by-step animation system for neural networks
            const stepContainer = document.getElementById('stepIndicator');
            if (!stepContainer) return;
            
            const steps = [
                'Input Layer: Raw pixel data (RGB values)',
                'Hidden Layer 1: Feature extraction (edges, textures)', 
                'Hidden Layer 2: Pattern recognition (shapes, objects)',
                'Output Layer: Classification/Generation decisions'
            ];
            
            stepContainer.innerHTML = steps.map((step, index) => 
                `<div class="step-item" id="step-${index}">
                    <div class="step-number">${index + 1}</div>
                    <div class="step-text">${step}</div>
                </div>`
            ).join('');
        }
        
        function initializeAttentionMatrix() {
            // Initialize attention mechanism visualization
            const attentionContainer = document.getElementById('attentionMatrix');
            if (!attentionContainer) return;
            
            const matrixSize = 4;
            let matrixHTML = '<div class="attention-grid">';
            
            for (let i = 0; i < matrixSize; i++) {
                for (let j = 0; j < matrixSize; j++) {
                    const attention = Math.random() * 0.8 + 0.2; // Random attention weights
                    matrixHTML += `<div class="attention-cell" 
                        data-row="${i}" data-col="${j}"
                        style="opacity: ${attention}; background: hsl(210, 100%, ${50 + attention * 20}%)"
                        onclick="showAttentionDetails(${i}, ${j}, ${attention.toFixed(3)})">
                        ${attention.toFixed(2)}
                    </div>`;
                }
            }
            
            matrixHTML += '</div>';
            attentionContainer.innerHTML = matrixHTML;
        }
        
        function showAttentionDetails(row, col, value) {
            showModal('🧠 Attention Mechanism', 
                `Position (${row}, ${col}) has attention weight: ${value}\\n\\nThis means the model is paying ${(value * 100).toFixed(1)}% attention to this part of the input when making decisions.\\n\\nHigher values (brighter blue) indicate more important regions for the current prediction.`);
        }
        
        function activateNeuron(neuron, layer, index) {
            if (!neuron) return;
            
            neuron.classList.add('activated');
            
            // Create ripple effect
            const ripple = document.createElement('div');
            ripple.className = 'neuron-ripple';
            neuron.appendChild(ripple);
            
            const analysis = document.getElementById('neuralNetworkAnalysis');
            if (analysis) {
                const layerSizes = { input: 3, hidden: 4, output: 2 };
                
                analysis.innerHTML = `
                    <strong>🧠 Neuron Activation Analysis:</strong><br>
                    <strong>Layer:</strong> ${layer.charAt(0).toUpperCase() + layer.slice(1)}<br>
                    <strong>Index:</strong> ${index}<br>
                    <strong>Function:</strong> z = Σ(w_i × x_i) + b, a = ReLU(z)<br>
                    <strong>Connections:</strong> ${layer === 'input' ? 'None (input data)' : `${layerSizes[layer === 'hidden' ? 'input' : 'hidden']} incoming weights`}<br>
                    <strong>Output:</strong> ${(Math.random() * 0.8 + 0.1).toFixed(3)}
                `;
            }
            
            // Propagate activation to next layer
            setTimeout(() => {
                propagateActivation(layer, index);
            }, 500);
            
            setTimeout(() => {
                neuron.classList.remove('activated');
                if (ripple.parentNode) ripple.remove();
            }, 1500);
        }
        
        function propagateActivation(fromLayer, fromIndex) {
            // Simulate forward propagation
            const layerMap = { input: 'hidden', hidden: 'output' };
            const nextLayer = layerMap[fromLayer];
            if (!nextLayer) return;
            
            const nextNeurons = document.querySelectorAll(`.${nextLayer}-neuron`);
            nextNeurons.forEach((neuron, index) => {
                setTimeout(() => {
                    neuron.style.transform = 'scale(1.1)';
                    neuron.style.backgroundColor = '#34C759';
                    
                    setTimeout(() => {
                        neuron.style.transform = 'scale(1)';
                        neuron.style.backgroundColor = '';
                    }, 300);
                }, index * 100);
            });
        }

        function forwardPropagate() {
            const layers = ['input', 'hidden', 'output'];
            let delay = 0;
            
            layers.forEach((layer, layerIndex) => {
                setTimeout(() => {
                    const neurons = document.querySelectorAll(`[data-layer="${layer}"]`);
                    neurons.forEach(neuron => neuron.classList.add('activated'));
                    
                    if (layerIndex < layers.length - 1) {
                        const connection = document.getElementById(`connection${layerIndex + 1}`);
                        connection.classList.add('active');
                    }
                    
                    setTimeout(() => {
                        neurons.forEach(neuron => neuron.classList.remove('activated'));
                        if (layerIndex < layers.length - 1) {
                            const connection = document.getElementById(`connection${layerIndex + 1}`);
                            connection.classList.remove('active');
                        }
                    }, 1000);
                    
                }, delay);
                delay += 1200;
            });
        }

        function resetNetwork() {
            const neurons = document.querySelectorAll('.neuron');
            const connections = document.querySelectorAll('.connection');
            
            neurons.forEach(neuron => neuron.classList.remove('activated'));
            connections.forEach(connection => connection.classList.remove('active'));
            
            document.getElementById('neuralNetworkAnalysis').innerHTML = 
                '<strong>Network Analysis:</strong> Click on any neuron to see its mathematical computation and how it affects downstream neurons.';
        }

        // Diffusion Demo Functions
        function initializeStepIndicator() {
            const indicator = document.getElementById('stepIndicator');
            indicator.innerHTML = '';
            
            for (let i = 0; i < maxDiffusionSteps; i++) {
                const step = document.createElement('div');
                step.className = 'step';
                indicator.appendChild(step);
            }
        }

        function startForwardDiffusion() {
            isForwardProcess = true;
            diffusionStep = 0;
            
            const noiseLayer = document.getElementById('noiseLayer');
            const progress = document.getElementById('diffusionProgress');
            const status = document.getElementById('diffusionStatus');
            const steps = document.querySelectorAll('.step');
            
            status.textContent = 'Forward Diffusion: Adding noise step by step...';
            
            const interval = setInterval(() => {
                diffusionStep++;
                const progressPercent = (diffusionStep / maxDiffusionSteps) * 100;
                
                progress.style.width = progressPercent + '%';
                noiseLayer.style.opacity = diffusionStep / maxDiffusionSteps;
                
                if (diffusionStep <= steps.length) {
                    steps[diffusionStep - 1].classList.add('active');
                }
                
                if (diffusionStep >= maxDiffusionSteps) {
                    clearInterval(interval);
                    status.textContent = '✨ Forward process complete! Pure noise achieved. Now try reverse diffusion!';
                }
            }, 100);
        }

        function startReverseDiffusion() {
            isForwardProcess = false;
            diffusionStep = maxDiffusionSteps;
            
            const noiseLayer = document.getElementById('noiseLayer');
            const progress = document.getElementById('diffusionProgress');
            const status = document.getElementById('diffusionStatus');
            const steps = document.querySelectorAll('.step');
            
            status.textContent = 'Reverse Diffusion: Neural network removing noise step by step...';
            
            const interval = setInterval(() => {
                diffusionStep--;
                const progressPercent = ((maxDiffusionSteps - diffusionStep) / maxDiffusionSteps) * 100;
                
                progress.style.width = progressPercent + '%';
                noiseLayer.style.opacity = diffusionStep / maxDiffusionSteps;
                
                if (diffusionStep >= 0 && diffusionStep < steps.length) {
                    steps[diffusionStep].classList.remove('active');
                }
                
                if (diffusionStep <= 0) {
                    clearInterval(interval);
                    status.textContent = '🎨 Reverse diffusion complete! Clean image recovered from noise!';
                }
            }, 150);
        }

        function resetDiffusion() {
            diffusionStep = 0;
            const noiseLayer = document.getElementById('noiseLayer');
            const progress = document.getElementById('diffusionProgress');
            const status = document.getElementById('diffusionStatus');
            const steps = document.querySelectorAll('.step');
            
            noiseLayer.style.opacity = 0;
            progress.style.width = '0%';
            status.textContent = 'Ready for diffusion experiment. Choose forward or reverse process.';
            
            steps.forEach(step => step.classList.remove('active'));
        }

        // Attention Matrix Functions
        function initializeAttentionMatrix() {
            const matrix = document.getElementById('attentionMatrix');
            matrix.innerHTML = '';
            
            const words = ['A', 'fluffy', 'white', 'cat', 'sits', 'gracefully', 'on', 'the'];
            
            for (let i = 0; i < 64; i++) {
                const cell = document.createElement('div');
                cell.className = 'attention-cell';
                cell.onclick = () => showAttentionWeight(i, words);
                matrix.appendChild(cell);
            }
        }

        function showAttentionWeight(index, words) {
            const row = Math.floor(index / 8);
            const col = index % 8;
            const cell = document.querySelector(`#attentionMatrix .attention-cell:nth-child(${index + 1})`);
            
            cell.classList.add('highlighted');
            setTimeout(() => cell.classList.remove('highlighted'), 2000);
            
            const queryWord = words[row] || `word${row}`;
            const keyWord = words[col] || `word${col}`;
            const attentionWeight = Math.random().toFixed(3);
            
            document.getElementById('attentionExplanation').innerHTML = `
                <strong>Attention Weight Analysis:</strong><br>
                <strong>Query:</strong> "${queryWord}" (position ${row})<br>
                <strong>Key:</strong> "${keyWord}" (position ${col})<br>
                <strong>Attention Score:</strong> ${attentionWeight}<br>
                <strong>Interpretation:</strong> "${queryWord}" pays ${(attentionWeight * 100).toFixed(1)}% attention to "${keyWord}"<br>
                <strong>Mathematical:</strong> softmax(Q[${row}] ⊙ K[${col}] / √d_k) = ${attentionWeight}
            `;
        }

        function showAttentionPattern(type) {
            const cells = document.querySelectorAll('.attention-cell');
            cells.forEach(cell => cell.classList.remove('highlighted'));
            
            const patterns = {
                subject: [0, 9, 18, 27], // Diagonal for subject-verb relationships
                verb: [32, 33, 34, 35], // Row for verb attending to all
                location: [54, 55, 62, 63] // Corner for location context
            };
            
            patterns[type].forEach(index => {
                if (cells[index]) {
                    cells[index].classList.add('highlighted');
                }
            });
            
            const explanations = {
                subject: 'Pattern shows how "cat" (subject) attends to related words for context understanding.',
                verb: 'Pattern shows how "sits" (verb) attends broadly to establish the action context.',
                location: 'Pattern shows how location words ("on", "windowsill") attend to spatial relationships.'
            };
            
            document.getElementById('attentionExplanation').innerHTML = `
                <strong>Attention Pattern: ${type.charAt(0).toUpperCase() + type.slice(1)}</strong><br>
                ${explanations[type]}
            `;
        }

        function resetAttention() {
            const cells = document.querySelectorAll('.attention-cell');
            cells.forEach(cell => cell.classList.remove('highlighted'));
            
            document.getElementById('attentionExplanation').innerHTML = 
                '<strong>Attention Analysis:</strong> Click on the matrix above to see how different words attend to each other.';
        }

        // Calculator Functions
        function updateCalculations() {
            // Real-time updates as user types
            const images = parseInt(document.getElementById('trainingImages').value);
            const rank = parseInt(document.getElementById('loraRank').value);
            
            if (images && rank) {
                // Update some basic calculations in real-time
                const estimatedParams = (4096 * rank + rank * 4096) / 1000000;
                console.log(`Estimated parameters: ${estimatedParams.toFixed(2)}M`);
            }
        }

        function calculateOptimalParameters() {
            const images = parseInt(document.getElementById('trainingImages').value);
            const rank = parseInt(document.getElementById('loraRank').value);
            const lr = parseFloat(document.getElementById('learningRate').value);
            const type = document.getElementById('trainingType').value;
            const quality = document.getElementById('dataQuality').value;
            const gpu = parseInt(document.getElementById('gpuMemory').value);
            
            // Advanced calculation logic
            const baseMultipliers = {
                character: { base: 60, complexity: 1.3 },
                style: { base: 80, complexity: 1.0 },
                concept: { base: 100, complexity: 1.2 },
                photorealism: { base: 120, complexity: 1.1 }
            };
            
            const qualityMultipliers = {
                high: 0.9,
                medium: 1.0,
                mixed: 1.2
            };
            
            const multiplier = baseMultipliers[type];
            const steps = Math.round(images * multiplier.base * multiplier.complexity * qualityMultipliers[quality]);
            const clampedSteps = Math.max(500, Math.min(6000, steps));
            
            const trainTime = Math.round(clampedSteps / 250 * 1.5);
            const samples = Math.floor(clampedSteps / 250);
            const cost = Math.round(trainTime * 0.5);
            const memoryUsage = Math.round((12 + rank * 0.1) * 100) / 100;
            
            const canTrain = memoryUsage <= gpu;
            const batchSize = Math.max(1, Math.floor(gpu / 20));
            
            document.getElementById('calculatorResults').style.display = 'block';
            document.getElementById('calculatorResults').innerHTML = `
                <h4>🎯 Optimized Training Configuration</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px 0;">
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                        <h5 style="color: var(--accent-gold); margin-bottom: 10px;">Core Parameters</h5>
                        <p><strong>Optimal Steps:</strong> ${clampedSteps}</p>
                        <p><strong>Learning Rate:</strong> ${lr}</p>
                        <p><strong>LoRA Rank:</strong> ${rank}</p>
                        <p><strong>Batch Size:</strong> ${batchSize}</p>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                        <h5 style="color: var(--accent-gold); margin-bottom: 10px;">Resource Usage</h5>
                        <p><strong>Memory Required:</strong> ${memoryUsage}GB</p>
                        <p><strong>Training Time:</strong> ~${trainTime} hours</p>
                        <p><strong>Estimated Cost:</strong> $${cost}</p>
                        <p><strong>Sample Images:</strong> ${samples}</p>
                    </div>
                </div>
                
                <div style="background: ${canTrain ? 'rgba(5, 150, 105, 0.2)' : 'rgba(220, 38, 38, 0.2)'}; border: 2px solid ${canTrain ? 'var(--success)' : 'var(--error)'}; border-radius: 10px; padding: 15px; margin: 20px 0;">
                    <h5>${canTrain ? '✅' : '❌'} GPU Compatibility</h5>
                    <p>${canTrain ? 'Your GPU has sufficient memory for this configuration.' : `Insufficient GPU memory. Consider reducing LoRA rank to ${Math.max(4, Math.floor((gpu - 12) / 0.1))} or upgrading to ${memoryUsage + 4}GB+ GPU.`}</p>
                </div>
                
                <h4>📋 Recommended AI-Toolkit Config</h4>
                <div style="background: #1a1a2e; border-radius: 10px; padding: 20px; font-family: monospace; overflow-x: auto; margin: 15px 0;">
<pre style="margin: 0; color: #e2e8f0;"><span style="color: #7c3aed;">train:</span>
  <span style="color: #059669;">steps:</span> ${clampedSteps}
  <span style="color: #059669;">batch_size:</span> ${batchSize}
  <span style="color: #059669;">lr:</span> ${lr}
  
<span style="color: #7c3aed;">network:</span>
  <span style="color: #059669;">type:</span> "lora"
  <span style="color: #059669;">linear:</span> ${rank}
  <span style="color: #059669;">linear_alpha:</span> ${rank}
  
<span style="color: #7c3aed;">save:</span>
  <span style="color: #059669;">save_every:</span> 250
  <span style="color: #059669;">max_step_saves_to_keep:</span> 4</pre>
                </div>
                
                <h4>💡 Training Tips</h4>
                <ul style="margin: 15px 0 0 20px;">
                    <li><strong>Monitor samples:</strong> Check generated images every 250 steps</li>
                    <li><strong>Early stopping:</strong> Stop if quality peaks before final step</li>
                    <li><strong>Learning rate:</strong> Reduce by 50% if loss oscillates</li>
                    <li><strong>Rank adjustment:</strong> Increase rank if underfitting, decrease if overfitting</li>
                </ul>
            `;
        }

        // FLUX Component Explanations
        function explainComponent(component) {
            const explanations = {
                flowmatching: {
                    title: '🌊 Flow Matching Deep Dive',
                    content: `
                        <h4>Mathematical Foundation:</h4>
                        <p>Flow matching provides a continuous-time formulation of the diffusion process:</p>
                        <pre style="background: #1a1a2e; padding: 15px; border-radius: 8px; margin: 10px 0;"><code>dX_t = v_θ(X_t, t)dt + σ(t)dW_t

Where:
• v_θ = velocity field (learned by neural network)
• σ(t) = noise schedule
• dW_t = Brownian motion increment</code></pre>
                        <p><strong>Advantages:</strong></p>
                        <ul>
                            <li>Fewer sampling steps (20-50 vs 1000)</li>
                            <li>More stable training dynamics</li>
                            <li>Better sample quality</li>
                            <li>Faster convergence</li>
                        </ul>
                    `
                },
                dualencoder: {
                    title: '📝 Dual Text Encoder Architecture',
                    content: `
                        <h4>CLIP + T5-XXL Combination:</h4>
                        <p>FLUX uses two complementary text encoders:</p>
                        <ul>
                            <li><strong>CLIP:</strong> Visual-semantic alignment, 77 token limit</li>
                            <li><strong>T5-XXL:</strong> Deep language understanding, 512 token capacity</li>
                        </ul>
                        <pre style="background: #1a1a2e; padding: 15px; border-radius: 8px; margin: 10px 0;"><code>text_embedding = concat([
    CLIP_encode(prompt),
    T5_encode(prompt)
])

# Results in richer text representation
# Better understanding of complex prompts
# Improved adherence to detailed descriptions</code></pre>
                    `
                },
                mmdit: {
                    title: '🏗️ Multimodal Diffusion Transformer (MMDiT)',
                    content: `
                        <h4>Joint Processing Architecture:</h4>
                        <p>MMDiT processes text and image tokens together in the same transformer:</p>
                        <pre style="background: #1a1a2e; padding: 15px; border-radius: 8px; margin: 10px 0;"><code>def forward(image_tokens, text_tokens):
    # Concatenate modalities
    joint_tokens = concat([image_tokens, text_tokens])
    
    # Process through transformer blocks
    for block in transformer_blocks:
        joint_tokens = block(joint_tokens)
    
    # Split back to modalities
    image_out, text_out = split(joint_tokens)
    return image_out</code></pre>
                        <p><strong>Benefits:</strong> Better cross-modal understanding, unified representation learning</p>
                    `
                },
                guidance: {
                    title: '🎯 Guidance-Free Training',
                    content: `
                        <h4>Eliminating Classifier-Free Guidance Artifacts:</h4>
                        <p>Traditional diffusion models use classifier-free guidance during training:</p>
                        <pre style="background: #1a1a2e; padding: 15px; border-radius: 8px; margin: 10px 0;"><code># Traditional CFG
if random() < 0.1:
    text_condition = null  # Unconditional training

# FLUX approach
# Always use condition, learn to balance naturally
text_condition = text_encoder(prompt)</code></pre>
                        <p><strong>Results:</strong> More natural images, fewer artifacts, better prompt adherence</p>
                    `
                }
            };
            
            const explanation = explanations[component];
            document.getElementById('componentExplanation').innerHTML = `
                <h3>${explanation.title}</h3>
                ${explanation.content}
            `;
        }

        // Quiz Functions
        function selectQuizOption(option, isCorrect) {
            const siblings = option.parentNode.querySelectorAll('.quiz-option');
            siblings.forEach(sibling => {
                sibling.style.pointerEvents = 'none';
                if (sibling === option) {
                    sibling.classList.add(isCorrect ? 'correct' : 'incorrect');
                } else if (sibling.onclick.toString().includes('true')) {
                    sibling.classList.add('correct');
                }
            });
            
            if (isCorrect) {
                quizScore++;
            }
            
            setTimeout(() => {
                checkQuizCompletion();
            }, 1000);
        }

        function checkQuizCompletion() {
            const answeredQuestions = document.querySelectorAll('.quiz-option.correct, .quiz-option.incorrect').length / 4;
            if (answeredQuestions >= totalQuestions) {
                document.getElementById('quizResults').style.display = 'block';
                document.getElementById('quizResults').innerHTML = `
                    <h4>🎉 Assessment Complete!</h4>
                    <p>Score: ${quizScore}/${totalQuestions} (${Math.round(quizScore/totalQuestions*100)}%)</p>
                    <p>${quizScore === totalQuestions ? 'Perfect score! You truly understand these concepts.' : 'Good progress! Review the material and try again for mastery.'}</p>
                `;
            }
        }

        // Celebration Function
        function celebrateCompletion() {
            // Create advanced celebration animation
            for (let i = 0; i < 100; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.style.position = 'fixed';
                    confetti.style.left = Math.random() * window.innerWidth + 'px';
                    confetti.style.top = '-10px';
                    confetti.style.width = '10px';
                    confetti.style.height = '10px';
                    confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
                    confetti.style.borderRadius = '50%';
                    confetti.style.pointerEvents = 'none';
                    confetti.style.zIndex = '10000';
                    confetti.style.animation = 'fall 4s linear forwards';
                    document.body.appendChild(confetti);
                    
                    setTimeout(() => confetti.remove(), 4000);
                }, i * 30);
            }
            
            setTimeout(() => {
                showModal('🎓 Congratulations, Professor!', `You have mastered:
✅ Neural Network Mathematics
✅ Diffusion Model Theory  
✅ Transformer Architecture
✅ FLUX Innovations
✅ LoRA Implementation
✅ Framework Development

You're now ready to push the boundaries of AI image generation!

Next steps:
1. Build your own training framework
2. Contribute to open-source projects
3. Publish your research
4. Teach others what you've learned

The future of AI is in your hands! 🚀`);
            }, 2000);
        }

        // RGB Demo Functions
        function updateRGBDemo() {
            const red = parseInt(document.getElementById('redSlider').value);
            const green = parseInt(document.getElementById('greenSlider').value);
            const blue = parseInt(document.getElementById('blueSlider').value);
            
            // Update display values
            document.getElementById('redValue').textContent = red;
            document.getElementById('greenValue').textContent = green;
            document.getElementById('blueValue').textContent = blue;
            
            // Update color display
            const colorDisplay = document.getElementById('rgbColorDisplay');
            colorDisplay.style.background = `rgb(${red}, ${green}, ${blue})`;
            
            // Update text displays
            document.getElementById('rgbDisplay').textContent = `(${red}, ${green}, ${blue})`;
            
            // Convert to hex
            const toHex = (n) => n.toString(16).padStart(2, '0').toUpperCase();
            document.getElementById('hexDisplay').textContent = `#${toHex(red)}${toHex(green)}${toHex(blue)}`;
            
            // Convert to binary
            const toBinary = (n) => n.toString(2).padStart(8, '0');
            document.getElementById('redBinary').textContent = toBinary(red);
            document.getElementById('greenBinary').textContent = toBinary(green);
            document.getElementById('blueBinary').textContent = toBinary(blue);
            
            // Update analysis
            const totalBits = 24;
            const memoryBytes = 3;
            document.getElementById('rgbAnalysis').innerHTML = `
                <strong>Color Analysis:</strong><br>
                <strong>Memory Usage:</strong> ${memoryBytes} bytes (${totalBits} bits)<br>
                <strong>Transistors Required:</strong> ${totalBits} (DRAM) or ${totalBits * 6} (SRAM)<br>
                <strong>Color Index:</strong> ${(red << 16) + (green << 8) + blue} out of 16,777,215<br>
                <strong>Luminance:</strong> ${Math.round(0.299 * red + 0.587 * green + 0.114 * blue)} (perceived brightness)
            `;
        }

        // Transistor-level memory functions
        let currentBitArray = [1, 0, 0, 0, 0, 0, 0, 0]; // Default: 128

        function toggleBit(pairElement, bitIndex) {
            // Toggle the bit value
            currentBitArray[bitIndex] = 1 - currentBitArray[bitIndex];
            
            const transistor = pairElement.querySelector('.transistor');
            const capacitor = pairElement.querySelector('.capacitor');
            const bitValue = pairElement.querySelector('.bit-value');
            
            // Update visual state
            if (currentBitArray[bitIndex] === 1) {
                transistor.classList.add('active');
                capacitor.classList.add('charged');
                bitValue.textContent = '1';
            } else {
                transistor.classList.remove('active');
                capacitor.classList.remove('charged');
                bitValue.textContent = '0';
            }
            
            // Calculate current value
            let decimalValue = 0;
            for (let i = 0; i < 8; i++) {
                decimalValue += currentBitArray[i] * Math.pow(2, 7 - i);
            }
            
            // Update displays
            document.getElementById('currentRedValue').textContent = decimalValue;
            document.getElementById('memoryRedBinary').textContent = currentBitArray.join('');
            
            // Generate fake memory address
            const baseAddress = 0x7F800000;
            const offset = Math.floor(Math.random() * 0x1000);
            document.getElementById('memoryAddress').textContent = (baseAddress + offset).toString(16).toUpperCase();
            
            // Add animation
            pairElement.classList.add('memory-access');
            setTimeout(() => pairElement.classList.remove('memory-access'), 800);
        }

        function demonstrateMemoryAccess() {
            const pairs = document.querySelectorAll('.transistor-pair');
            let delay = 0;
            
            pairs.forEach((pair, index) => {
                setTimeout(() => {
                    pair.classList.add('data-flow');
                    setTimeout(() => pair.classList.remove('data-flow'), 1500);
                }, delay);
                delay += 200;
            });
            
            setTimeout(() => {
                showModal('Memory Access Complete!', `During this simulation:
• CPU requested byte at address 0x${document.getElementById('memoryAddress').textContent}
• Memory controller activated row and column decoders
• 8 transistors were read simultaneously
• Each capacitor's charge was sensed and amplified
• Binary data ${document.getElementById('memoryRedBinary').textContent} was returned
• Total access time: ~10 nanoseconds

This happens billions of times per second in your computer!`);
            }, 2000);
        }

        function showParameterMemory() {
            const redValue = parseInt(document.getElementById('currentRedValue').textContent);
            
            // Calculate FLUX model memory usage
            const fluxParams = 12e9; // 12 billion parameters
            const bytesPerParam = 4; // FP32
            const totalGB = (fluxParams * bytesPerParam) / (1024**3);
            
            showModal('AI Model Parameters vs Single Pixel', `🎨 CURRENT PIXEL (Red Channel):
• Value: ${redValue}
• Storage: 8 bits = 8 transistors
• Memory: 1 byte

🤖 FLUX.1-DEV MODEL:
• Parameters: 12,000,000,000
• Storage: ${fluxParams * 32} bits = ${fluxParams * 32} transistors
• Memory: ${totalGB.toFixed(1)} GB (${fluxParams * bytesPerParam} bytes)

Mind-blowing fact: Your single red pixel uses 8 transistors.
FLUX uses 384,000,000,000 transistors for its parameters!

That's 48 billion times more transistors than your single pixel!`);
        }

        function resetMemoryDemo() {
            // Reset to default value (128 = 10000000)
            currentBitArray = [1, 0, 0, 0, 0, 0, 0, 0];
            
            const pairs = document.querySelectorAll('.transistor-pair');
            pairs.forEach((pair, index) => {
                const transistor = pair.querySelector('.transistor');
                const capacitor = pair.querySelector('.capacitor');
                const bitValue = pair.querySelector('.bit-value');
                
                if (index === 0) {
                    transistor.classList.add('active');
                    capacitor.classList.add('charged');
                    bitValue.textContent = '1';
                } else {
                    transistor.classList.remove('active');
                    capacitor.classList.remove('charged');
                    bitValue.textContent = '0';
                }
            });
            
            document.getElementById('currentRedValue').textContent = '128';
            document.getElementById('memoryRedBinary').textContent = '10000000';
        }

        // Gaussian Noise Demonstration Functions
        function generateNoiseComparison() {
            generateUniformNoise();
            generateSaltPepperNoise();
            generateGaussianNoise();
            
            document.getElementById('noiseAnalysis').innerHTML = `
                <strong>Statistical Analysis:</strong><br>
                <strong>Uniform Noise:</strong> Equal probability for all values - creates harsh transitions<br>
                <strong>Salt & Pepper:</strong> Only extreme values (0 or 255) - no gradual changes<br>
                <strong>Gaussian Noise:</strong> Natural distribution with smooth gradients - perfect for training<br>
                <br>
                <em>Neural networks need smooth, differentiable functions. Only Gaussian noise provides this!</em>
            `;
        }

        function generateUniformNoise() {
            const canvas = document.getElementById('uniformNoiseCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(200, 200);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                const value = Math.floor(Math.random() * 256);
                imageData.data[i] = value;     // Red
                imageData.data[i + 1] = value; // Green
                imageData.data[i + 2] = value; // Blue
                imageData.data[i + 3] = 255;   // Alpha
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function generateSaltPepperNoise() {
            const canvas = document.getElementById('saltPepperCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(200, 200);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                const value = Math.random() < 0.5 ? 0 : 255;
                imageData.data[i] = value;     // Red
                imageData.data[i + 1] = value; // Green
                imageData.data[i + 2] = value; // Blue
                imageData.data[i + 3] = 255;   // Alpha
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function generateGaussianNoise() {
            const canvas = document.getElementById('gaussianNoiseCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(200, 200);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                // Box-Muller transform for Gaussian noise
                const u1 = Math.random();
                const u2 = Math.random();
                const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                const value = Math.max(0, Math.min(255, Math.round(128 + z * 40)));
                
                imageData.data[i] = value;     // Red
                imageData.data[i + 1] = value; // Green
                imageData.data[i + 2] = value; // Blue
                imageData.data[i + 3] = 255;   // Alpha
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function showNoiseHistograms() {
            // This would show distribution plots
            showModal('Noise Distribution Analysis', `📊 UNIFORM NOISE:
• Distribution: Flat (equal probability)
• Mean: 127.5
• Standard Deviation: ~74
• Gradient: Discontinuous at boundaries

📊 SALT & PEPPER NOISE:
• Distribution: Two peaks at 0 and 255
• Mean: ~127.5 (but meaningless)
• Standard Deviation: ~127.5
• Gradient: Undefined (discrete jumps)

📊 GAUSSIAN NOISE:
• Distribution: Bell curve (normal)
• Mean: 128 (configurable)
• Standard Deviation: 40 (configurable)
• Gradient: Smooth and continuous everywhere

🎯 For neural networks, we need:
1. Smooth derivatives → Gaussian ✓
2. Mathematical tractability → Gaussian ✓
3. Stable training → Gaussian ✓`);
        }

        function demonstrateGradientFlow() {
            showModal('Gradient Flow Analysis', `When training neural networks, we need ∂L/∂x to exist everywhere.

❌ UNIFORM NOISE:
∂/∂x uniform(x) = 0 inside [a,b], undefined at boundaries
→ Zero gradients = no learning!

❌ SALT & PEPPER:
∂/∂x discrete(x) = undefined everywhere
→ Cannot backpropagate!

✅ GAUSSIAN NOISE:
∂/∂x exp(-x²/2σ²) = -(x/σ²) exp(-x²/2σ²)
→ Smooth gradients everywhere!

This is why every successful diffusion model (DDPM, DDIM, FLUX) uses Gaussian noise. It's not a design choice - it's a mathematical requirement!`);
        }

        // Advanced Gaussian property demonstrations
        function demonstrateClosure() {
            const canvas = document.getElementById('closureDemo');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 300, 200);
            
            // Draw two Gaussian curves
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < 300; x++) {
                const t = (x - 75) / 30;
                const y = 100 - 50 * Math.exp(-t * t / 2);
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            ctx.strokeStyle = '#4444ff';
            ctx.beginPath();
            for (let x = 0; x < 300; x++) {
                const t = (x - 150) / 25;
                const y = 100 - 40 * Math.exp(-t * t / 2);
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw sum (also Gaussian)
            ctx.strokeStyle = '#44ff44';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let x = 0; x < 300; x++) {
                const t = (x - 112.5) / 35;
                const y = 100 - 60 * Math.exp(-t * t / 2);
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Add labels
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.fillText('N(μ₁,σ₁²)', 10, 30);
            ctx.fillText('N(μ₂,σ₂²)', 120, 30);
            ctx.fillText('N(μ₁+μ₂, σ₁²+σ₂²)', 160, 190);
        }

        function demonstrateGradients() {
            const canvas = document.getElementById('gradientDemo');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 300, 200);
            
            // Draw Gaussian function
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < 300; x++) {
                const t = (x - 150) / 40;
                const y = 100 - 60 * Math.exp(-t * t / 2);
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw gradient arrows
            for (let x = 50; x < 300; x += 50) {
                const t = (x - 150) / 40;
                const y = 100 - 60 * Math.exp(-t * t / 2);
                const gradient = -(t / 40) * Math.exp(-t * t / 2);
                
                // Draw gradient arrow
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + gradient * 20, y - 20);
                ctx.stroke();
                
                // Arrow head
                ctx.beginPath();
                ctx.moveTo(x + gradient * 20, y - 20);
                ctx.lineTo(x + gradient * 20 - 5, y - 15);
                ctx.moveTo(x + gradient * 20, y - 20);
                ctx.lineTo(x + gradient * 20 + 5, y - 15);
                ctx.stroke();
            }
            
            // Labels
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.fillText('f(x) = exp(-x²/2σ²)', 10, 20);
            ctx.fillText("f'(x) = -(x/σ²)exp(-x²/2σ²)", 10, 190);
        }

        function calculateEntropy() {
            // Gaussian entropy: H = 0.5 * log(2πeσ²)
            const sigma = 1.0; // standard deviation
            const entropy = 0.5 * Math.log(2 * Math.PI * Math.E * sigma * sigma);
            const entropyBits = entropy / Math.log(2);
            
            document.getElementById('entropyValue').textContent = `Entropy: ${entropyBits.toFixed(2)} bits`;
            
            setTimeout(() => {
                showModal('Entropy Calculation', `For Gaussian distribution N(0,1):
H(X) = ½log(2πeσ²)
H(X) = ½log(2π × e × 1²)
H(X) = ½log(17.08)
H(X) = ${entropyBits.toFixed(3)} bits

This is the MAXIMUM possible entropy for any distribution with variance σ² = 1.

Why this matters:
• Maximum entropy = maximum information content
• No other distribution carries more information per bit
• Perfect for efficient neural network training`);
            }, 500);
        }

        let rotationActive = false;

        function demonstrateRotation() {
            if (!rotationActive) return;
            
            const canvas = document.getElementById('rotationDemo');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 300, 200);
            
            const centerX = 150, centerY = 100;
            const angle = Date.now() * 0.001; // Rotating angle
            
            // Draw rotated 2D Gaussian
            for (let i = 0; i < 500; i++) {
                // Generate Gaussian-distributed point
                const u1 = Math.random();
                const u2 = Math.random();
                const z1 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                const z2 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);
                
                // Rotate the point
                const x = z1 * Math.cos(angle) - z2 * Math.sin(angle);
                const y = z1 * Math.sin(angle) + z2 * Math.cos(angle);
                
                // Scale and translate
                const px = centerX + x * 20;
                const py = centerY + y * 20;
                
                if (px >= 0 && px < 300 && py >= 0 && py < 200) {
                    ctx.fillStyle = `rgba(245, 158, 11, ${Math.exp(-(x*x + y*y)/2) * 0.3})`;
                    ctx.fillRect(px, py, 2, 2);
                }
            }
            
            // Continue animation
            setTimeout(() => demonstrateRotation(), 100);
        }

        // Add fall animation for confetti
        if (!document.querySelector('#fall-animation')) {
            const style = document.createElement('style');
            style.id = 'fall-animation';
            style.textContent = `
                @keyframes fall {
                    to {
                        transform: translateY(100vh) rotate(720deg);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }

        // Enhanced Interactive Bit/Byte Demo Functions
        let singleBitValue = 0;
        let nibbleBits = [0, 0, 0, 0];
        let byteBits = [1, 0, 1, 0, 1, 0, 1, 0];

        function toggleSingleBit() {
            singleBitValue = 1 - singleBitValue;
            const bitElement = document.querySelector('#singleBit .bit-visual');
            const physicsElement = document.getElementById('bitPhysics');
            
            bitElement.textContent = singleBitValue;
            bitElement.parentNode.classList.add('bit-changing');
            setTimeout(() => bitElement.parentNode.classList.remove('bit-changing'), 600);
            
            if (singleBitValue === 1) {
                physicsElement.textContent = "⚡ Charged capacitor = HIGH voltage = 1";
                bitElement.parentNode.style.background = 'var(--gradient-accent)';
            } else {
                physicsElement.textContent = "🔋 Discharged capacitor = LOW voltage = 0";
                bitElement.parentNode.style.background = 'var(--gradient-primary)';
            }
        }

        function toggleNibbleBit(index) {
            nibbleBits[index] = 1 - nibbleBits[index];
            const nibbleBitElements = document.querySelectorAll('.nibble-bit');
            const bitElement = nibbleBitElements[index].querySelector('.bit-visual');
            
            bitElement.textContent = nibbleBits[index];
            nibbleBitElements[index].classList.add('bit-changing');
            setTimeout(() => nibbleBitElements[index].classList.remove('bit-changing'), 600);
            
            // Calculate decimal value
            let decimal = 0;
            for (let i = 0; i < 4; i++) {
                decimal += nibbleBits[i] * Math.pow(2, 3 - i);
            }
            
            document.getElementById('nibbleValue').textContent = decimal;
            document.getElementById('nibbleHex').textContent = decimal.toString(16).toUpperCase();
            
            // Update styling
            if (nibbleBits[index] === 1) {
                nibbleBitElements[index].style.background = 'var(--gradient-accent)';
            } else {
                nibbleBitElements[index].style.background = 'linear-gradient(135deg, var(--accent-purple) 0%, var(--primary-blue) 100%)';
            }
        }

        function toggleByteBit(index) {
            byteBits[index] = 1 - byteBits[index];
            const byteBitElements = document.querySelectorAll('.byte-bit');
            
            byteBitElements[index].textContent = byteBits[index];
            byteBitElements[index].classList.add('bit-changing');
            setTimeout(() => byteBitElements[index].classList.remove('bit-changing'), 600);
            
            // Update styling
            if (byteBits[index] === 1) {
                byteBitElements[index].classList.remove('zero');
                byteBitElements[index].style.background = 'var(--gradient-accent)';
            } else {
                byteBitElements[index].classList.add('zero');
                byteBitElements[index].style.background = 'linear-gradient(135deg, #cbd5e1 0%, #94a3b8 100%)';
            }
            
            // Calculate values
            let decimal = 0;
            for (let i = 0; i < 8; i++) {
                decimal += byteBits[i] * Math.pow(2, 7 - i);
            }
            
            const binary = byteBits.join('');
            const ascii = decimal >= 32 && decimal <= 126 ? String.fromCharCode(decimal) : '�';
            
            document.getElementById('byteValue').textContent = binary;
            document.getElementById('byteDecimal').textContent = decimal;
            document.getElementById('byteAscii').textContent = ascii;
        }

        function startByteAnimation() {
            const elements = [
                document.getElementById('singleBit'),
                ...document.querySelectorAll('.nibble-bit'),
                ...document.querySelectorAll('.byte-bit')
            ];
            
            elements.forEach((element, index) => {
                setTimeout(() => {
                    element.classList.add('data-flow');
                    setTimeout(() => element.classList.remove('data-flow'), 2000);
                }, index * 100);
            });
            
            // Show animation explanation
            setTimeout(() => {
                showModal('🎬 Data Flow Animation Complete!', `This simulation showed:
• Individual bits lighting up in sequence
• Data propagating through memory hierarchies
• How bits combine to form larger data structures

In real computers:
• This happens at ~3 GHz (3 billion times per second)
• Multiple data paths operate simultaneously
• Cache hierarchies optimize access patterns
• Modern CPUs process 64+ bits simultaneously`);
            }, elements.length * 100 + 2000);
        }

        function randomizeBits() {
            // Randomize single bit
            singleBitValue = Math.random() < 0.5 ? 0 : 1;
            const bitElement = document.querySelector('#singleBit .bit-visual');
            bitElement.textContent = singleBitValue;
            
            // Randomize nibble
            for (let i = 0; i < 4; i++) {
                nibbleBits[i] = Math.random() < 0.5 ? 0 : 1;
                toggleNibbleBit(i);
                toggleNibbleBit(i); // Toggle twice to set value without changing it again
            }
            
            // Randomize byte
            for (let i = 0; i < 8; i++) {
                byteBits[i] = Math.random() < 0.5 ? 0 : 1;
                toggleByteBit(i);
                toggleByteBit(i); // Toggle twice to set value without changing it again
            }
        }

        function resetBitDemo() {
            // Reset single bit
            singleBitValue = 0;
            document.querySelector('#singleBit .bit-visual').textContent = '0';
            document.getElementById('singleBit').style.background = 'var(--gradient-primary)';
            
            // Reset nibble
            nibbleBits = [0, 0, 0, 0];
            const nibbleElements = document.querySelectorAll('.nibble-bit');
            nibbleElements.forEach((element, index) => {
                element.querySelector('.bit-visual').textContent = '0';
                element.style.background = 'linear-gradient(135deg, var(--accent-purple) 0%, var(--primary-blue) 100%)';
            });
            document.getElementById('nibbleValue').textContent = '0';
            document.getElementById('nibbleHex').textContent = '0';
            
            // Reset byte
            byteBits = [1, 0, 1, 0, 1, 0, 1, 0];
            const byteElements = document.querySelectorAll('.byte-bit');
            byteElements.forEach((element, index) => {
                element.textContent = byteBits[index];
                if (byteBits[index] === 1) {
                    element.classList.remove('zero');
                    element.style.background = 'var(--gradient-accent)';
                } else {
                    element.classList.add('zero');
                    element.style.background = 'linear-gradient(135deg, #cbd5e1 0%, #94a3b8 100%)';
                }
            });
            
            // Update byte display
            document.getElementById('byteValue').textContent = '10101010';
            document.getElementById('byteDecimal').textContent = '170';
            document.getElementById('byteAscii').textContent = 'ª';
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializePixelMatrix();
            initializeStepIndicator();
            initializeAttentionMatrix();
            updateCalculations();
            
            // Initialize RGB demo
            if (document.getElementById('redSlider')) {
                updateRGBDemo();
            }
            
            // Initialize noise demos
            if (document.getElementById('uniformNoiseCanvas')) {
                generateNoiseComparison();
            }
            
            // Initialize bit/byte demo
            resetBitDemo();
            
            // Start rotation demo
            rotationActive = true;
            setTimeout(() => demonstrateRotation(), 1000);
            
            // Add staggered animations for sections
            const sections = document.querySelectorAll('.section');
            sections.forEach((section, index) => {
                setTimeout(() => {
                    section.style.animationDelay = `${index * 0.1}s`;
                }, 100);
            });
        });

        // Apple-style Modal and Notification System
        function showModal(title, content) {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-body').textContent = content;
            
            const overlay = document.getElementById('modal-overlay');
            overlay.classList.add('show');
            
            // Focus trap
            document.addEventListener('keydown', handleModalKeyDown);
        }

        function hideModal() {
            const overlay = document.getElementById('modal-overlay');
            overlay.classList.remove('show');
            document.removeEventListener('keydown', handleModalKeyDown);
        }

        function handleModalKeyDown(e) {
            if (e.key === 'Escape') {
                hideModal();
            }
        }

        // Click outside modal to close
        document.getElementById('modal-overlay').addEventListener('click', (e) => {
            if (e.target.id === 'modal-overlay') {
                hideModal();
            }
        });

        function showNotification(title, message, type = 'info') {
            const container = document.getElementById('notification-container');
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            
            const notificationId = 'notification-' + Date.now();
            notification.id = notificationId;
            
            notification.innerHTML = `
                <button class="notification-close" onclick="hideNotification('${notificationId}')">×</button>
                <div class="notification-title">${title}</div>
                <div class="notification-message">${message}</div>
            `;
            
            container.appendChild(notification);
            
            // Trigger animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                hideNotification(notificationId);
            }, 5000);
        }

        function hideNotification(notificationId) {
            const notification = document.getElementById(notificationId);
            if (notification) {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 400);
            }
        }

        // Practice Question System
        function selectAnswer(element, questionId, option, isCorrect) {
            // Find all options for this question
            const questionContainer = element.parentNode;
            const allOptions = questionContainer.querySelectorAll('.question-option');
            
            // Reset all options
            allOptions.forEach(opt => {
                opt.classList.remove('selected', 'correct', 'incorrect');
            });
            
            // Mark the selected option
            element.classList.add('selected');
            
            if (isCorrect) {
                element.classList.add('correct');
                showNotification('🎉 Correct!', `Great job! You selected the right answer (${option}).`, 'success');
                
                // Show explanation after a delay
                setTimeout(() => {
                    const explanationId = `explanation-${questionId}`;
                    const explanation = document.getElementById(explanationId);
                    if (explanation) {
                        explanation.classList.add('show');
                    }
                }, 1000);
            } else {
                element.classList.add('incorrect');
                showNotification('💡 Try Again', `That's not quite right. Think about what makes this approach mathematically superior.`, 'warning');
                
                // Highlight correct answer after wrong selection
                setTimeout(() => {
                    allOptions.forEach(opt => {
                        const onclick = opt.getAttribute('onclick');
                        if (onclick && onclick.includes(', true)')) {
                            opt.classList.add('correct');
                        }
                    });
                }, 2000);
            }
        }

        // Language Toggle System
        let currentLanguage = 'en';
        
        const translations = {
            en: {
                title: '🎓 AI Image Generation',
                subtitle: 'Complete Academic Course: From Mathematics to Implementation',
                instructor: 'Course Instructor Style: Andrew Ng & David J. Malan',
                developed: 'Developed by: Yuval Avidani (YUV.AI)',
                quote: 'The best way to learn is to understand the underlying principles, see them in action, and build upon them.',
                objectives: '📚 Course Learning Objectives',
                objectivesText: 'By the end of this course, you will:',
                langButton: '🌐 עברית'
            },
            he: {
                title: '🎓 יצירת תמונות בבינה מלאכותית',
                subtitle: 'קורס אקדמי מקיף: מ-מתמטיקה ועד להטמעה',
                instructor: 'סגנון ההוראה: אנדרו נג ודוד מאלאן',
                developed: 'פותח על ידי: יובל אבידני (YUV.AI)',
                quote: 'הדרך הטובה ביותר ללמוד היא להבין את העקרונות הבסיסיים, לראות אותם בפעולה, ולבנות עליהם.',
                objectives: '📚 יעדי הלמידה של הקורס',
                objectivesText: 'בסוף הקורס תוכלו:',
                langButton: '🌐 English'
            }
        };
        
        function toggleLanguage() {
            currentLanguage = currentLanguage === 'en' ? 'he' : 'en';
            updateLanguage();
        }
        
        function updateLanguage() {
            const body = document.body;
            const langToggle = document.getElementById('langToggle');
            const t = translations[currentLanguage];
            
            // Toggle RTL/LTR
            if (currentLanguage === 'he') {
                body.classList.add('rtl');
            } else {
                body.classList.remove('rtl');
            }
            
            // Update button text
            langToggle.textContent = t.langButton;
            
            // Update main content
            const titleElement = document.querySelector('.lecture-header h1');
            const subtitleElement = document.querySelector('.subtitle');
            const instructorElement = document.querySelector('.professor-attribution h3');
            const developedElement = document.querySelector('.professor-attribution p:first-of-type strong:first-of-type');
            const quoteElement = document.querySelector('.professor-attribution em');
            const objectivesTitle = document.querySelector('.section h2');
            const objectivesText = document.querySelector('.learning-objective h4');
            
            if (titleElement) titleElement.textContent = t.title;
            if (subtitleElement) subtitleElement.textContent = t.subtitle;
            if (instructorElement) instructorElement.textContent = t.instructor;
            if (quoteElement) quoteElement.textContent = `"${t.quote}"`;
            if (objectivesTitle) objectivesTitle.textContent = t.objectives;
            if (objectivesText) objectivesText.textContent = t.objectivesText;
            
            // Update developed by section
            if (developedElement && developedElement.parentNode) {
                developedElement.parentNode.innerHTML = `<strong>${t.developed.split(':')[0]}:</strong> ${t.developed.split(':')[1]}`;
            }
            
            // Show notification about language change
            const langName = currentLanguage === 'he' ? 'עברית' : 'English';
            showNotification(
                currentLanguage === 'he' ? '🌐 שפה שונתה' : '🌐 Language Changed',
                currentLanguage === 'he' ? `הממשק עבר ל${langName}` : `Interface switched to ${langName}`,
                'info'
            );
        }
    </script>

    <!-- Apple-style Modal System -->
    <div id="modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title" class="modal-title"></h2>
            </div>
            <div id="modal-body" class="modal-body"></div>
            <div class="modal-footer">
                <button class="modal-close" onclick="hideModal()">Got it</button>
            </div>
        </div>
    </div>

    <!-- Notification Container -->
    <div id="notification-container"></div>

</body>
</html>